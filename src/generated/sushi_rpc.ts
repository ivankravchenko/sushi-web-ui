// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: sushi_rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "sushi_rpc";

export interface GenericVoidValue {
}

export interface GenericFloatValue {
  value: number;
}

export interface GenericIntValue {
  value: number;
}

export interface GenericBoolValue {
  value: boolean;
}

export interface GenericStringValue {
  value: string;
}

export interface FloatResponse {
  status: CommandStatus | undefined;
  value: number;
}

export interface IntResponse {
  status: CommandStatus | undefined;
  value: number;
}

export interface BoolResponse {
  status: CommandStatus | undefined;
  value: boolean;
}

export interface StringResponse {
  status: CommandStatus | undefined;
  value: string;
}

export interface OptionalBoolValue {
  hasValue: boolean;
  value: boolean;
}

export interface OptionalIntValue {
  hasValue: boolean;
  value: number;
}

export interface CommandStatus {
  status: CommandStatus_Status;
}

export enum CommandStatus_Status {
  DUMMY = 0,
  SUCCESS = 1,
  ASYNC_RESPONSE = 2,
  ERROR = 3,
  UNSUPPORTED_OPERATION = 4,
  NOT_FOUND = 5,
  OUT_OF_RANGE = 6,
  INVALID_ARGUMENTS = 7,
  UNRECOGNIZED = -1,
}

export function commandStatus_StatusFromJSON(object: any): CommandStatus_Status {
  switch (object) {
    case 0:
    case "DUMMY":
      return CommandStatus_Status.DUMMY;
    case 1:
    case "SUCCESS":
      return CommandStatus_Status.SUCCESS;
    case 2:
    case "ASYNC_RESPONSE":
      return CommandStatus_Status.ASYNC_RESPONSE;
    case 3:
    case "ERROR":
      return CommandStatus_Status.ERROR;
    case 4:
    case "UNSUPPORTED_OPERATION":
      return CommandStatus_Status.UNSUPPORTED_OPERATION;
    case 5:
    case "NOT_FOUND":
      return CommandStatus_Status.NOT_FOUND;
    case 6:
    case "OUT_OF_RANGE":
      return CommandStatus_Status.OUT_OF_RANGE;
    case 7:
    case "INVALID_ARGUMENTS":
      return CommandStatus_Status.INVALID_ARGUMENTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandStatus_Status.UNRECOGNIZED;
  }
}

export function commandStatus_StatusToJSON(object: CommandStatus_Status): string {
  switch (object) {
    case CommandStatus_Status.DUMMY:
      return "DUMMY";
    case CommandStatus_Status.SUCCESS:
      return "SUCCESS";
    case CommandStatus_Status.ASYNC_RESPONSE:
      return "ASYNC_RESPONSE";
    case CommandStatus_Status.ERROR:
      return "ERROR";
    case CommandStatus_Status.UNSUPPORTED_OPERATION:
      return "UNSUPPORTED_OPERATION";
    case CommandStatus_Status.NOT_FOUND:
      return "NOT_FOUND";
    case CommandStatus_Status.OUT_OF_RANGE:
      return "OUT_OF_RANGE";
    case CommandStatus_Status.INVALID_ARGUMENTS:
      return "INVALID_ARGUMENTS";
    case CommandStatus_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CommandResponse {
  status: CommandStatus | undefined;
  id: number;
}

export interface AsyncCommandResponse {
  status: CommandStatus | undefined;
  requestId: number;
}

export interface SushiBuildInfo {
  version: string;
  buildOptions: string[];
  audioBufferSize: number;
  commitHash: string;
  buildDate: string;
}

export interface TrackIdentifier {
  id: number;
}

export interface TrackIdentifierResponse {
  status: CommandStatus | undefined;
  id: number;
}

export interface ProcessorIdentifier {
  id: number;
}

export interface ProcessorIdentifierResponse {
  status: CommandStatus | undefined;
  id: number;
}

export interface ParameterIdentifier {
  processorId: number;
  parameterId: number;
}

export interface ParameterIdentifierResponse {
  status: CommandStatus | undefined;
  id: ParameterIdentifier | undefined;
}

export interface PropertyIdentifier {
  processorId: number;
  propertyId: number;
}

export interface PropertyIdentifierResponse {
  status: CommandStatus | undefined;
  id: PropertyIdentifier | undefined;
}

/** 0 is reserved for "not set" in protobuf, so we don't use it for a valid response */
export interface ParameterType {
  type: ParameterType_Type;
}

export enum ParameterType_Type {
  DUMMY = 0,
  BOOL = 1,
  INT = 2,
  FLOAT = 3,
  UNRECOGNIZED = -1,
}

export function parameterType_TypeFromJSON(object: any): ParameterType_Type {
  switch (object) {
    case 0:
    case "DUMMY":
      return ParameterType_Type.DUMMY;
    case 1:
    case "BOOL":
      return ParameterType_Type.BOOL;
    case 2:
    case "INT":
      return ParameterType_Type.INT;
    case 3:
    case "FLOAT":
      return ParameterType_Type.FLOAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParameterType_Type.UNRECOGNIZED;
  }
}

export function parameterType_TypeToJSON(object: ParameterType_Type): string {
  switch (object) {
    case ParameterType_Type.DUMMY:
      return "DUMMY";
    case ParameterType_Type.BOOL:
      return "BOOL";
    case ParameterType_Type.INT:
      return "INT";
    case ParameterType_Type.FLOAT:
      return "FLOAT";
    case ParameterType_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PlayingMode {
  mode: PlayingMode_Mode;
}

export enum PlayingMode_Mode {
  DUMMY = 0,
  STOPPED = 1,
  PLAYING = 2,
  RECORDING = 3,
  UNRECOGNIZED = -1,
}

export function playingMode_ModeFromJSON(object: any): PlayingMode_Mode {
  switch (object) {
    case 0:
    case "DUMMY":
      return PlayingMode_Mode.DUMMY;
    case 1:
    case "STOPPED":
      return PlayingMode_Mode.STOPPED;
    case 2:
    case "PLAYING":
      return PlayingMode_Mode.PLAYING;
    case 3:
    case "RECORDING":
      return PlayingMode_Mode.RECORDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PlayingMode_Mode.UNRECOGNIZED;
  }
}

export function playingMode_ModeToJSON(object: PlayingMode_Mode): string {
  switch (object) {
    case PlayingMode_Mode.DUMMY:
      return "DUMMY";
    case PlayingMode_Mode.STOPPED:
      return "STOPPED";
    case PlayingMode_Mode.PLAYING:
      return "PLAYING";
    case PlayingMode_Mode.RECORDING:
      return "RECORDING";
    case PlayingMode_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SyncMode {
  mode: SyncMode_Mode;
}

export enum SyncMode_Mode {
  DUMMY = 0,
  INTERNAL = 1,
  MIDI = 2,
  LINK = 3,
  UNRECOGNIZED = -1,
}

export function syncMode_ModeFromJSON(object: any): SyncMode_Mode {
  switch (object) {
    case 0:
    case "DUMMY":
      return SyncMode_Mode.DUMMY;
    case 1:
    case "INTERNAL":
      return SyncMode_Mode.INTERNAL;
    case 2:
    case "MIDI":
      return SyncMode_Mode.MIDI;
    case 3:
    case "LINK":
      return SyncMode_Mode.LINK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SyncMode_Mode.UNRECOGNIZED;
  }
}

export function syncMode_ModeToJSON(object: SyncMode_Mode): string {
  switch (object) {
    case SyncMode_Mode.DUMMY:
      return "DUMMY";
    case SyncMode_Mode.INTERNAL:
      return "INTERNAL";
    case SyncMode_Mode.MIDI:
      return "MIDI";
    case SyncMode_Mode.LINK:
      return "LINK";
    case SyncMode_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TimeSignature {
  numerator: number;
  denominator: number;
}

export interface Timings {
  average: number;
  min: number;
  max: number;
}

export interface CpuTimings {
  main: Timings | undefined;
  threads: Timings[];
}

export interface TimingResponse {
  status: CommandStatus | undefined;
  timings: Timings | undefined;
}

export interface NoteOnRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  note: number;
  velocity: number;
}

export interface NoteOffRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  note: number;
  velocity: number;
}

export interface NoteAftertouchRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  note: number;
  value: number;
}

export interface NoteModulationRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  value: number;
}

export interface TrackType {
  type: TrackType_Type;
}

export enum TrackType_Type {
  DUMMY = 0,
  REGULAR = 1,
  PRE = 2,
  POST = 3,
  UNRECOGNIZED = -1,
}

export function trackType_TypeFromJSON(object: any): TrackType_Type {
  switch (object) {
    case 0:
    case "DUMMY":
      return TrackType_Type.DUMMY;
    case 1:
    case "REGULAR":
      return TrackType_Type.REGULAR;
    case 2:
    case "PRE":
      return TrackType_Type.PRE;
    case 3:
    case "POST":
      return TrackType_Type.POST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrackType_Type.UNRECOGNIZED;
  }
}

export function trackType_TypeToJSON(object: TrackType_Type): string {
  switch (object) {
    case TrackType_Type.DUMMY:
      return "DUMMY";
    case TrackType_Type.REGULAR:
      return "REGULAR";
    case TrackType_Type.PRE:
      return "PRE";
    case TrackType_Type.POST:
      return "POST";
    case TrackType_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TrackInfo {
  id: number;
  label: string;
  name: string;
  channels: number;
  buses: number;
  thread: number;
  type: TrackType | undefined;
  processors: ProcessorIdentifier[];
}

export interface TrackInfoResponse {
  status: CommandStatus | undefined;
  info: TrackInfo | undefined;
}

export interface TrackInfoList {
  tracks: TrackInfo[];
}

export interface ProcessorInfo {
  id: number;
  label: string;
  name: string;
  parameterCount: number;
  programCount: number;
}

export interface ProcessorInfoResponse {
  status: CommandStatus | undefined;
  processor: ProcessorInfo | undefined;
}

export interface ProcessorInfoList {
  processors: ProcessorInfo[];
}

export interface ProcessorInfoListResponse {
  status: CommandStatus | undefined;
  processors: ProcessorInfo[];
}

export interface ProgramIdentifier {
  program: number;
}

export interface ProgramIdentifierResponse {
  status: CommandStatus | undefined;
  program: number;
}

export interface ProcessorProgramIdentifier {
  processor: ProcessorIdentifier | undefined;
  program: number;
}

export interface ProgramInfo {
  id: ProgramIdentifier | undefined;
  name: string;
}

export interface ProgramInfoList {
  programs: ProgramInfo[];
}

export interface ProgramInfoListResponse {
  status: CommandStatus | undefined;
  programs: ProgramInfo[];
}

export interface ProcessorProgramSetRequest {
  processor: ProcessorIdentifier | undefined;
  program: ProgramIdentifier | undefined;
}

export interface ProcessorBypassStateSetRequest {
  processor: ProcessorIdentifier | undefined;
  value: boolean;
}

export interface ProcessorState {
  programId: OptionalIntValue | undefined;
  bypassed: OptionalBoolValue | undefined;
  properties: PropertyValue[];
  parameters: ParameterValue[];
  binaryData: Uint8Array;
}

export interface ProcessorStateResponse {
  status: CommandStatus | undefined;
  state: ProcessorState | undefined;
}

export interface ProcessorStateSetRequest {
  processor: ProcessorIdentifier | undefined;
  state: ProcessorState | undefined;
}

export interface ParameterInfo {
  id: number;
  type: ParameterType | undefined;
  label: string;
  name: string;
  unit: string;
  automatable: boolean;
  minDomainValue: number;
  maxDomainValue: number;
}

export interface ParameterInfoResponse {
  status: CommandStatus | undefined;
  info: ParameterInfo | undefined;
}

export interface ParameterInfoList {
  parameters: ParameterInfo[];
}

export interface ParameterInfoListResponse {
  status: CommandStatus | undefined;
  parameters: ParameterInfo[];
}

export interface ParameterIdRequest {
  processor: ProcessorIdentifier | undefined;
  ParameterName: string;
}

export interface ParameterValue {
  parameter: ParameterIdentifier | undefined;
  value: number;
}

export interface ParameterUpdate {
  parameter: ParameterIdentifier | undefined;
  normalizedValue: number;
  domainValue: number;
  formattedValue: string;
}

export interface PropertyInfo {
  id: number;
  name: string;
  label: string;
}

export interface PropertyInfoResponse {
  status: CommandStatus | undefined;
  info: PropertyInfo | undefined;
}

export interface PropertyInfoList {
  properties: PropertyInfo[];
}

export interface PropertyInfoListResponse {
  status: CommandStatus | undefined;
  properties: PropertyInfo[];
}

export interface PropertyValue {
  property: PropertyIdentifier | undefined;
  value: string;
}

export interface PropertyIdRequest {
  processor: ProcessorIdentifier | undefined;
  propertyName: string;
}

export interface PluginType {
  type: PluginType_Type;
}

export enum PluginType_Type {
  DUMMY = 0,
  INTERNAL = 1,
  VST2X = 2,
  VST3X = 3,
  LV2 = 4,
  UNRECOGNIZED = -1,
}

export function pluginType_TypeFromJSON(object: any): PluginType_Type {
  switch (object) {
    case 0:
    case "DUMMY":
      return PluginType_Type.DUMMY;
    case 1:
    case "INTERNAL":
      return PluginType_Type.INTERNAL;
    case 2:
    case "VST2X":
      return PluginType_Type.VST2X;
    case 3:
    case "VST3X":
      return PluginType_Type.VST3X;
    case 4:
    case "LV2":
      return PluginType_Type.LV2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PluginType_Type.UNRECOGNIZED;
  }
}

export function pluginType_TypeToJSON(object: PluginType_Type): string {
  switch (object) {
    case PluginType_Type.DUMMY:
      return "DUMMY";
    case PluginType_Type.INTERNAL:
      return "INTERNAL";
    case PluginType_Type.VST2X:
      return "VST2X";
    case PluginType_Type.VST3X:
      return "VST3X";
    case PluginType_Type.LV2:
      return "LV2";
    case PluginType_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProcessorPosition {
  addToBack: boolean;
  beforeProcessor: ProcessorIdentifier | undefined;
}

export interface CreateTrackRequest {
  name: string;
  channels: number;
  thread: OptionalIntValue | undefined;
}

export interface CreateMultibusTrackRequest {
  name: string;
  buses: number;
  thread: OptionalIntValue | undefined;
}

export interface CreatePreTrackRequest {
  name: string;
}

export interface CreatePostTrackRequest {
  name: string;
}

export interface CreateProcessorRequest {
  name: string;
  uid: string;
  path: string;
  type: PluginType | undefined;
  track: TrackIdentifier | undefined;
  position: ProcessorPosition | undefined;
}

export interface MoveProcessorRequest {
  processor: ProcessorIdentifier | undefined;
  sourceTrack: TrackIdentifier | undefined;
  destTrack: TrackIdentifier | undefined;
  position: ProcessorPosition | undefined;
}

export interface DeleteProcessorRequest {
  processor: ProcessorIdentifier | undefined;
  track: TrackIdentifier | undefined;
}

export interface ParameterNotificationBlocklist {
  parameters: ParameterIdentifier[];
}

export interface PropertyNotificationBlocklist {
  properties: PropertyIdentifier[];
}

export interface MidiChannel {
  channel: MidiChannel_Channel;
}

export enum MidiChannel_Channel {
  DUMMY = 0,
  MIDI_CH_1 = 1,
  MIDI_CH_2 = 2,
  MIDI_CH_3 = 3,
  MIDI_CH_4 = 4,
  MIDI_CH_5 = 5,
  MIDI_CH_6 = 6,
  MIDI_CH_7 = 7,
  MIDI_CH_8 = 8,
  MIDI_CH_9 = 9,
  MIDI_CH_10 = 10,
  MIDI_CH_11 = 11,
  MIDI_CH_12 = 12,
  MIDI_CH_13 = 13,
  MIDI_CH_14 = 14,
  MIDI_CH_15 = 15,
  MIDI_CH_16 = 16,
  MIDI_CH_OMNI = 17,
  UNRECOGNIZED = -1,
}

export function midiChannel_ChannelFromJSON(object: any): MidiChannel_Channel {
  switch (object) {
    case 0:
    case "DUMMY":
      return MidiChannel_Channel.DUMMY;
    case 1:
    case "MIDI_CH_1":
      return MidiChannel_Channel.MIDI_CH_1;
    case 2:
    case "MIDI_CH_2":
      return MidiChannel_Channel.MIDI_CH_2;
    case 3:
    case "MIDI_CH_3":
      return MidiChannel_Channel.MIDI_CH_3;
    case 4:
    case "MIDI_CH_4":
      return MidiChannel_Channel.MIDI_CH_4;
    case 5:
    case "MIDI_CH_5":
      return MidiChannel_Channel.MIDI_CH_5;
    case 6:
    case "MIDI_CH_6":
      return MidiChannel_Channel.MIDI_CH_6;
    case 7:
    case "MIDI_CH_7":
      return MidiChannel_Channel.MIDI_CH_7;
    case 8:
    case "MIDI_CH_8":
      return MidiChannel_Channel.MIDI_CH_8;
    case 9:
    case "MIDI_CH_9":
      return MidiChannel_Channel.MIDI_CH_9;
    case 10:
    case "MIDI_CH_10":
      return MidiChannel_Channel.MIDI_CH_10;
    case 11:
    case "MIDI_CH_11":
      return MidiChannel_Channel.MIDI_CH_11;
    case 12:
    case "MIDI_CH_12":
      return MidiChannel_Channel.MIDI_CH_12;
    case 13:
    case "MIDI_CH_13":
      return MidiChannel_Channel.MIDI_CH_13;
    case 14:
    case "MIDI_CH_14":
      return MidiChannel_Channel.MIDI_CH_14;
    case 15:
    case "MIDI_CH_15":
      return MidiChannel_Channel.MIDI_CH_15;
    case 16:
    case "MIDI_CH_16":
      return MidiChannel_Channel.MIDI_CH_16;
    case 17:
    case "MIDI_CH_OMNI":
      return MidiChannel_Channel.MIDI_CH_OMNI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MidiChannel_Channel.UNRECOGNIZED;
  }
}

export function midiChannel_ChannelToJSON(object: MidiChannel_Channel): string {
  switch (object) {
    case MidiChannel_Channel.DUMMY:
      return "DUMMY";
    case MidiChannel_Channel.MIDI_CH_1:
      return "MIDI_CH_1";
    case MidiChannel_Channel.MIDI_CH_2:
      return "MIDI_CH_2";
    case MidiChannel_Channel.MIDI_CH_3:
      return "MIDI_CH_3";
    case MidiChannel_Channel.MIDI_CH_4:
      return "MIDI_CH_4";
    case MidiChannel_Channel.MIDI_CH_5:
      return "MIDI_CH_5";
    case MidiChannel_Channel.MIDI_CH_6:
      return "MIDI_CH_6";
    case MidiChannel_Channel.MIDI_CH_7:
      return "MIDI_CH_7";
    case MidiChannel_Channel.MIDI_CH_8:
      return "MIDI_CH_8";
    case MidiChannel_Channel.MIDI_CH_9:
      return "MIDI_CH_9";
    case MidiChannel_Channel.MIDI_CH_10:
      return "MIDI_CH_10";
    case MidiChannel_Channel.MIDI_CH_11:
      return "MIDI_CH_11";
    case MidiChannel_Channel.MIDI_CH_12:
      return "MIDI_CH_12";
    case MidiChannel_Channel.MIDI_CH_13:
      return "MIDI_CH_13";
    case MidiChannel_Channel.MIDI_CH_14:
      return "MIDI_CH_14";
    case MidiChannel_Channel.MIDI_CH_15:
      return "MIDI_CH_15";
    case MidiChannel_Channel.MIDI_CH_16:
      return "MIDI_CH_16";
    case MidiChannel_Channel.MIDI_CH_OMNI:
      return "MIDI_CH_OMNI";
    case MidiChannel_Channel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AudioConnection {
  track: TrackIdentifier | undefined;
  trackChannel: number;
  engineChannel: number;
}

export interface AudioConnectionList {
  connections: AudioConnection[];
}

export interface AudioConnectionListResponse {
  status: CommandStatus | undefined;
  connections: AudioConnection[];
}

export interface CvConnection {
  parameter: ParameterIdentifier | undefined;
  cvPortId: number;
}

export interface CvConnectionList {
  connections: CvConnection[];
}

export interface CvConnectionListResponse {
  status: CommandStatus | undefined;
  connections: CvConnection[];
}

export interface GateConnection {
  processor: ProcessorIdentifier | undefined;
  gatePortId: number;
  channel: number;
  noteNo: number;
}

export interface GateConnectionList {
  connections: GateConnection[];
}

export interface GateConnectionListResponse {
  status: CommandStatus | undefined;
  connections: GateConnection[];
}

export interface MidiKbdConnection {
  track: TrackIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
  rawMidi: boolean;
}

export interface MidiKbdConnectionList {
  connections: MidiKbdConnection[];
}

export interface MidiCCConnection {
  parameter: ParameterIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
  ccNumber: number;
  minRange: number;
  maxRange: number;
  relativeMode: boolean;
}

export interface MidiCCConnectionList {
  connections: MidiCCConnection[];
}

export interface MidiCCConnectionListResponse {
  status: CommandStatus | undefined;
  connections: MidiCCConnection[];
}

export interface MidiPCConnection {
  processor: ProcessorIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
}

export interface MidiPCConnectionList {
  connections: MidiPCConnection[];
}

export interface MidiPCConnectionListResponse {
  status: CommandStatus | undefined;
  connections: MidiPCConnection[];
}

export interface MidiClockSetRequest {
  port: number;
  enabled: boolean;
}

export interface OscParameterOutputList {
  path: string[];
}

export interface TransportUpdate {
  tempo?: number | undefined;
  playingMode?: PlayingMode | undefined;
  syncMode?: SyncMode | undefined;
  timeSignature?: TimeSignature | undefined;
}

export interface TrackUpdate {
  action: TrackUpdate_Action;
  track: TrackIdentifier | undefined;
}

export enum TrackUpdate_Action {
  DUMMY = 0,
  TRACK_ADDED = 1,
  TRACK_DELETED = 2,
  UNRECOGNIZED = -1,
}

export function trackUpdate_ActionFromJSON(object: any): TrackUpdate_Action {
  switch (object) {
    case 0:
    case "DUMMY":
      return TrackUpdate_Action.DUMMY;
    case 1:
    case "TRACK_ADDED":
      return TrackUpdate_Action.TRACK_ADDED;
    case 2:
    case "TRACK_DELETED":
      return TrackUpdate_Action.TRACK_DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrackUpdate_Action.UNRECOGNIZED;
  }
}

export function trackUpdate_ActionToJSON(object: TrackUpdate_Action): string {
  switch (object) {
    case TrackUpdate_Action.DUMMY:
      return "DUMMY";
    case TrackUpdate_Action.TRACK_ADDED:
      return "TRACK_ADDED";
    case TrackUpdate_Action.TRACK_DELETED:
      return "TRACK_DELETED";
    case TrackUpdate_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProcessorUpdate {
  action: ProcessorUpdate_Action;
  processor: ProcessorIdentifier | undefined;
  parentTrack: TrackIdentifier | undefined;
}

export enum ProcessorUpdate_Action {
  DUMMY = 0,
  PROCESSOR_ADDED = 1,
  PROCESSOR_DELETED = 2,
  UNRECOGNIZED = -1,
}

export function processorUpdate_ActionFromJSON(object: any): ProcessorUpdate_Action {
  switch (object) {
    case 0:
    case "DUMMY":
      return ProcessorUpdate_Action.DUMMY;
    case 1:
    case "PROCESSOR_ADDED":
      return ProcessorUpdate_Action.PROCESSOR_ADDED;
    case 2:
    case "PROCESSOR_DELETED":
      return ProcessorUpdate_Action.PROCESSOR_DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProcessorUpdate_Action.UNRECOGNIZED;
  }
}

export function processorUpdate_ActionToJSON(object: ProcessorUpdate_Action): string {
  switch (object) {
    case ProcessorUpdate_Action.DUMMY:
      return "DUMMY";
    case ProcessorUpdate_Action.PROCESSOR_ADDED:
      return "PROCESSOR_ADDED";
    case ProcessorUpdate_Action.PROCESSOR_DELETED:
      return "PROCESSOR_DELETED";
    case ProcessorUpdate_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MidiKbdConnectionState {
  track: string;
  channel: MidiChannel | undefined;
  port: number;
  rawMidi: boolean;
}

export interface MidiCCConnectionState {
  processor: string;
  parameter: ParameterIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
  ccNumber: number;
  minRange: number;
  maxRange: number;
  relativeMode: boolean;
}

export interface MidiPCConnectionState {
  processor: string;
  channel: MidiChannel | undefined;
  port: number;
}

export interface MidiState {
  inputs: number;
  outputs: number;
  kbdInputConnections: MidiKbdConnectionState[];
  kbdOutputConnections: MidiKbdConnectionState[];
  ccConnections: MidiCCConnectionState[];
  pcConnections: MidiPCConnectionState[];
  enabledClockOutputs: number[];
}

export interface OscParameterState {
  processor: string;
  parameterIds: number[];
}

export interface OscState {
  enableAllProcessorOutputs: boolean;
  enabledProcessorOutputs: OscParameterState[];
}

export interface TrackAudioConnectionState {
  track: string;
  trackChannel: number;
  engineChannel: number;
}

export interface EngineState {
  sampleRate: number;
  tempo: number;
  playingMode: PlayingMode | undefined;
  syncMode: SyncMode | undefined;
  timeSignature: TimeSignature | undefined;
  clipDetectionInput: boolean;
  clipDetectionOutput: boolean;
  masterLimiter: boolean;
  usedAudioInputs: number;
  usedAudioOutputs: number;
  inputConnections: TrackAudioConnectionState[];
  outputConnections: TrackAudioConnectionState[];
}

export interface PluginClass {
  name: string;
  label: string;
  uid: string;
  path: string;
  type: PluginType | undefined;
  state: ProcessorState | undefined;
}

export interface TrackState {
  name: string;
  label: string;
  channels: number;
  buses: number;
  thread: number;
  type: TrackType | undefined;
  trackState: ProcessorState | undefined;
  processors: PluginClass[];
}

export interface SessionState {
  sushiInfo: SushiBuildInfo | undefined;
  saveDate: string;
  oscState: OscState | undefined;
  midiState: MidiState | undefined;
  engineState: EngineState | undefined;
  tracks: TrackState[];
}

function createBaseGenericVoidValue(): GenericVoidValue {
  return {};
}

export const GenericVoidValue: MessageFns<GenericVoidValue> = {
  encode(_: GenericVoidValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericVoidValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericVoidValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenericVoidValue {
    return {};
  },

  toJSON(_: GenericVoidValue): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GenericVoidValue>): GenericVoidValue {
    return GenericVoidValue.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GenericVoidValue>): GenericVoidValue {
    const message = createBaseGenericVoidValue();
    return message;
  },
};

function createBaseGenericFloatValue(): GenericFloatValue {
  return { value: 0 };
}

export const GenericFloatValue: MessageFns<GenericFloatValue> = {
  encode(message: GenericFloatValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericFloatValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericFloatValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericFloatValue {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: GenericFloatValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GenericFloatValue>): GenericFloatValue {
    return GenericFloatValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericFloatValue>): GenericFloatValue {
    const message = createBaseGenericFloatValue();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGenericIntValue(): GenericIntValue {
  return { value: 0 };
}

export const GenericIntValue: MessageFns<GenericIntValue> = {
  encode(message: GenericIntValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericIntValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericIntValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericIntValue {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: GenericIntValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GenericIntValue>): GenericIntValue {
    return GenericIntValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericIntValue>): GenericIntValue {
    const message = createBaseGenericIntValue();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGenericBoolValue(): GenericBoolValue {
  return { value: false };
}

export const GenericBoolValue: MessageFns<GenericBoolValue> = {
  encode(message: GenericBoolValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericBoolValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericBoolValue {
    return { value: isSet(object.value) ? globalThis.Boolean(object.value) : false };
  },

  toJSON(message: GenericBoolValue): unknown {
    const obj: any = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GenericBoolValue>): GenericBoolValue {
    return GenericBoolValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericBoolValue>): GenericBoolValue {
    const message = createBaseGenericBoolValue();
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseGenericStringValue(): GenericStringValue {
  return { value: "" };
}

export const GenericStringValue: MessageFns<GenericStringValue> = {
  encode(message: GenericStringValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericStringValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericStringValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: GenericStringValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GenericStringValue>): GenericStringValue {
    return GenericStringValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericStringValue>): GenericStringValue {
    const message = createBaseGenericStringValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFloatResponse(): FloatResponse {
  return { status: undefined, value: 0 };
}

export const FloatResponse: MessageFns<FloatResponse> = {
  encode(message: FloatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: FloatResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatResponse>): FloatResponse {
    return FloatResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatResponse>): FloatResponse {
    const message = createBaseFloatResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseIntResponse(): IntResponse {
  return { status: undefined, value: 0 };
}

export const IntResponse: MessageFns<IntResponse> = {
  encode(message: IntResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: IntResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<IntResponse>): IntResponse {
    return IntResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntResponse>): IntResponse {
    const message = createBaseIntResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBoolResponse(): BoolResponse {
  return { status: undefined, value: false };
}

export const BoolResponse: MessageFns<BoolResponse> = {
  encode(message: BoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: BoolResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BoolResponse>): BoolResponse {
    return BoolResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoolResponse>): BoolResponse {
    const message = createBaseBoolResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseStringResponse(): StringResponse {
  return { status: undefined, value: "" };
}

export const StringResponse: MessageFns<StringResponse> = {
  encode(message: StringResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StringResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StringResponse>): StringResponse {
    return StringResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringResponse>): StringResponse {
    const message = createBaseStringResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOptionalBoolValue(): OptionalBoolValue {
  return { hasValue: false, value: false };
}

export const OptionalBoolValue: MessageFns<OptionalBoolValue> = {
  encode(message: OptionalBoolValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasValue !== false) {
      writer.uint32(8).bool(message.hasValue);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionalBoolValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionalBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasValue = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionalBoolValue {
    return {
      hasValue: isSet(object.hasValue) ? globalThis.Boolean(object.hasValue) : false,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: OptionalBoolValue): unknown {
    const obj: any = {};
    if (message.hasValue !== false) {
      obj.hasValue = message.hasValue;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<OptionalBoolValue>): OptionalBoolValue {
    return OptionalBoolValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptionalBoolValue>): OptionalBoolValue {
    const message = createBaseOptionalBoolValue();
    message.hasValue = object.hasValue ?? false;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseOptionalIntValue(): OptionalIntValue {
  return { hasValue: false, value: 0 };
}

export const OptionalIntValue: MessageFns<OptionalIntValue> = {
  encode(message: OptionalIntValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasValue !== false) {
      writer.uint32(8).bool(message.hasValue);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionalIntValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionalIntValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasValue = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionalIntValue {
    return {
      hasValue: isSet(object.hasValue) ? globalThis.Boolean(object.hasValue) : false,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: OptionalIntValue): unknown {
    const obj: any = {};
    if (message.hasValue !== false) {
      obj.hasValue = message.hasValue;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<OptionalIntValue>): OptionalIntValue {
    return OptionalIntValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptionalIntValue>): OptionalIntValue {
    const message = createBaseOptionalIntValue();
    message.hasValue = object.hasValue ?? false;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCommandStatus(): CommandStatus {
  return { status: 0 };
}

export const CommandStatus: MessageFns<CommandStatus> = {
  encode(message: CommandStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandStatus {
    return { status: isSet(object.status) ? commandStatus_StatusFromJSON(object.status) : 0 };
  },

  toJSON(message: CommandStatus): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = commandStatus_StatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<CommandStatus>): CommandStatus {
    return CommandStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandStatus>): CommandStatus {
    const message = createBaseCommandStatus();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCommandResponse(): CommandResponse {
  return { status: undefined, id: 0 };
}

export const CommandResponse: MessageFns<CommandResponse> = {
  encode(message: CommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: CommandResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<CommandResponse>): CommandResponse {
    return CommandResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommandResponse>): CommandResponse {
    const message = createBaseCommandResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseAsyncCommandResponse(): AsyncCommandResponse {
  return { status: undefined, requestId: 0 };
}

export const AsyncCommandResponse: MessageFns<AsyncCommandResponse> = {
  encode(message: AsyncCommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.requestId !== 0) {
      writer.uint32(16).int32(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AsyncCommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsyncCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requestId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AsyncCommandResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
    };
  },

  toJSON(message: AsyncCommandResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    return obj;
  },

  create(base?: DeepPartial<AsyncCommandResponse>): AsyncCommandResponse {
    return AsyncCommandResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AsyncCommandResponse>): AsyncCommandResponse {
    const message = createBaseAsyncCommandResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.requestId = object.requestId ?? 0;
    return message;
  },
};

function createBaseSushiBuildInfo(): SushiBuildInfo {
  return { version: "", buildOptions: [], audioBufferSize: 0, commitHash: "", buildDate: "" };
}

export const SushiBuildInfo: MessageFns<SushiBuildInfo> = {
  encode(message: SushiBuildInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.buildOptions) {
      writer.uint32(18).string(v!);
    }
    if (message.audioBufferSize !== 0) {
      writer.uint32(24).int32(message.audioBufferSize);
    }
    if (message.commitHash !== "") {
      writer.uint32(34).string(message.commitHash);
    }
    if (message.buildDate !== "") {
      writer.uint32(42).string(message.buildDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SushiBuildInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSushiBuildInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buildOptions.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.audioBufferSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commitHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buildDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SushiBuildInfo {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      buildOptions: globalThis.Array.isArray(object?.buildOptions)
        ? object.buildOptions.map((e: any) => globalThis.String(e))
        : [],
      audioBufferSize: isSet(object.audioBufferSize) ? globalThis.Number(object.audioBufferSize) : 0,
      commitHash: isSet(object.commitHash) ? globalThis.String(object.commitHash) : "",
      buildDate: isSet(object.buildDate) ? globalThis.String(object.buildDate) : "",
    };
  },

  toJSON(message: SushiBuildInfo): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.buildOptions?.length) {
      obj.buildOptions = message.buildOptions;
    }
    if (message.audioBufferSize !== 0) {
      obj.audioBufferSize = Math.round(message.audioBufferSize);
    }
    if (message.commitHash !== "") {
      obj.commitHash = message.commitHash;
    }
    if (message.buildDate !== "") {
      obj.buildDate = message.buildDate;
    }
    return obj;
  },

  create(base?: DeepPartial<SushiBuildInfo>): SushiBuildInfo {
    return SushiBuildInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SushiBuildInfo>): SushiBuildInfo {
    const message = createBaseSushiBuildInfo();
    message.version = object.version ?? "";
    message.buildOptions = object.buildOptions?.map((e) => e) || [];
    message.audioBufferSize = object.audioBufferSize ?? 0;
    message.commitHash = object.commitHash ?? "";
    message.buildDate = object.buildDate ?? "";
    return message;
  },
};

function createBaseTrackIdentifier(): TrackIdentifier {
  return { id: 0 };
}

export const TrackIdentifier: MessageFns<TrackIdentifier> = {
  encode(message: TrackIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackIdentifier {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: TrackIdentifier): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<TrackIdentifier>): TrackIdentifier {
    return TrackIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackIdentifier>): TrackIdentifier {
    const message = createBaseTrackIdentifier();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseTrackIdentifierResponse(): TrackIdentifierResponse {
  return { status: undefined, id: 0 };
}

export const TrackIdentifierResponse: MessageFns<TrackIdentifierResponse> = {
  encode(message: TrackIdentifierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackIdentifierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackIdentifierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackIdentifierResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: TrackIdentifierResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<TrackIdentifierResponse>): TrackIdentifierResponse {
    return TrackIdentifierResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackIdentifierResponse>): TrackIdentifierResponse {
    const message = createBaseTrackIdentifierResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseProcessorIdentifier(): ProcessorIdentifier {
  return { id: 0 };
}

export const ProcessorIdentifier: MessageFns<ProcessorIdentifier> = {
  encode(message: ProcessorIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIdentifier {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: ProcessorIdentifier): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorIdentifier>): ProcessorIdentifier {
    return ProcessorIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorIdentifier>): ProcessorIdentifier {
    const message = createBaseProcessorIdentifier();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseProcessorIdentifierResponse(): ProcessorIdentifierResponse {
  return { status: undefined, id: 0 };
}

export const ProcessorIdentifierResponse: MessageFns<ProcessorIdentifierResponse> = {
  encode(message: ProcessorIdentifierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIdentifierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIdentifierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIdentifierResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: ProcessorIdentifierResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorIdentifierResponse>): ProcessorIdentifierResponse {
    return ProcessorIdentifierResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorIdentifierResponse>): ProcessorIdentifierResponse {
    const message = createBaseProcessorIdentifierResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseParameterIdentifier(): ParameterIdentifier {
  return { processorId: 0, parameterId: 0 };
}

export const ParameterIdentifier: MessageFns<ParameterIdentifier> = {
  encode(message: ParameterIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processorId !== 0) {
      writer.uint32(8).int32(message.processorId);
    }
    if (message.parameterId !== 0) {
      writer.uint32(16).int32(message.parameterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.parameterId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterIdentifier {
    return {
      processorId: isSet(object.processorId) ? globalThis.Number(object.processorId) : 0,
      parameterId: isSet(object.parameterId) ? globalThis.Number(object.parameterId) : 0,
    };
  },

  toJSON(message: ParameterIdentifier): unknown {
    const obj: any = {};
    if (message.processorId !== 0) {
      obj.processorId = Math.round(message.processorId);
    }
    if (message.parameterId !== 0) {
      obj.parameterId = Math.round(message.parameterId);
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterIdentifier>): ParameterIdentifier {
    return ParameterIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterIdentifier>): ParameterIdentifier {
    const message = createBaseParameterIdentifier();
    message.processorId = object.processorId ?? 0;
    message.parameterId = object.parameterId ?? 0;
    return message;
  },
};

function createBaseParameterIdentifierResponse(): ParameterIdentifierResponse {
  return { status: undefined, id: undefined };
}

export const ParameterIdentifierResponse: MessageFns<ParameterIdentifierResponse> = {
  encode(message: ParameterIdentifierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      ParameterIdentifier.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterIdentifierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterIdentifierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterIdentifierResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      id: isSet(object.id) ? ParameterIdentifier.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: ParameterIdentifierResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.id !== undefined) {
      obj.id = ParameterIdentifier.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterIdentifierResponse>): ParameterIdentifierResponse {
    return ParameterIdentifierResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterIdentifierResponse>): ParameterIdentifierResponse {
    const message = createBaseParameterIdentifierResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null)
      ? ParameterIdentifier.fromPartial(object.id)
      : undefined;
    return message;
  },
};

function createBasePropertyIdentifier(): PropertyIdentifier {
  return { processorId: 0, propertyId: 0 };
}

export const PropertyIdentifier: MessageFns<PropertyIdentifier> = {
  encode(message: PropertyIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processorId !== 0) {
      writer.uint32(8).int32(message.processorId);
    }
    if (message.propertyId !== 0) {
      writer.uint32(16).int32(message.propertyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.propertyId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyIdentifier {
    return {
      processorId: isSet(object.processorId) ? globalThis.Number(object.processorId) : 0,
      propertyId: isSet(object.propertyId) ? globalThis.Number(object.propertyId) : 0,
    };
  },

  toJSON(message: PropertyIdentifier): unknown {
    const obj: any = {};
    if (message.processorId !== 0) {
      obj.processorId = Math.round(message.processorId);
    }
    if (message.propertyId !== 0) {
      obj.propertyId = Math.round(message.propertyId);
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyIdentifier>): PropertyIdentifier {
    return PropertyIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyIdentifier>): PropertyIdentifier {
    const message = createBasePropertyIdentifier();
    message.processorId = object.processorId ?? 0;
    message.propertyId = object.propertyId ?? 0;
    return message;
  },
};

function createBasePropertyIdentifierResponse(): PropertyIdentifierResponse {
  return { status: undefined, id: undefined };
}

export const PropertyIdentifierResponse: MessageFns<PropertyIdentifierResponse> = {
  encode(message: PropertyIdentifierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      PropertyIdentifier.encode(message.id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyIdentifierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyIdentifierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = PropertyIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyIdentifierResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      id: isSet(object.id) ? PropertyIdentifier.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: PropertyIdentifierResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.id !== undefined) {
      obj.id = PropertyIdentifier.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyIdentifierResponse>): PropertyIdentifierResponse {
    return PropertyIdentifierResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyIdentifierResponse>): PropertyIdentifierResponse {
    const message = createBasePropertyIdentifierResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null)
      ? PropertyIdentifier.fromPartial(object.id)
      : undefined;
    return message;
  },
};

function createBaseParameterType(): ParameterType {
  return { type: 0 };
}

export const ParameterType: MessageFns<ParameterType> = {
  encode(message: ParameterType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterType {
    return { type: isSet(object.type) ? parameterType_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: ParameterType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = parameterType_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterType>): ParameterType {
    return ParameterType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterType>): ParameterType {
    const message = createBaseParameterType();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBasePlayingMode(): PlayingMode {
  return { mode: 0 };
}

export const PlayingMode: MessageFns<PlayingMode> = {
  encode(message: PlayingMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayingMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayingMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayingMode {
    return { mode: isSet(object.mode) ? playingMode_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: PlayingMode): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = playingMode_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<PlayingMode>): PlayingMode {
    return PlayingMode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayingMode>): PlayingMode {
    const message = createBasePlayingMode();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSyncMode(): SyncMode {
  return { mode: 0 };
}

export const SyncMode: MessageFns<SyncMode> = {
  encode(message: SyncMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncMode {
    return { mode: isSet(object.mode) ? syncMode_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: SyncMode): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = syncMode_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<SyncMode>): SyncMode {
    return SyncMode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncMode>): SyncMode {
    const message = createBaseSyncMode();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseTimeSignature(): TimeSignature {
  return { numerator: 0, denominator: 0 };
}

export const TimeSignature: MessageFns<TimeSignature> = {
  encode(message: TimeSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numerator !== 0) {
      writer.uint32(8).int32(message.numerator);
    }
    if (message.denominator !== 0) {
      writer.uint32(16).int32(message.denominator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numerator = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.denominator = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSignature {
    return {
      numerator: isSet(object.numerator) ? globalThis.Number(object.numerator) : 0,
      denominator: isSet(object.denominator) ? globalThis.Number(object.denominator) : 0,
    };
  },

  toJSON(message: TimeSignature): unknown {
    const obj: any = {};
    if (message.numerator !== 0) {
      obj.numerator = Math.round(message.numerator);
    }
    if (message.denominator !== 0) {
      obj.denominator = Math.round(message.denominator);
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSignature>): TimeSignature {
    return TimeSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSignature>): TimeSignature {
    const message = createBaseTimeSignature();
    message.numerator = object.numerator ?? 0;
    message.denominator = object.denominator ?? 0;
    return message;
  },
};

function createBaseTimings(): Timings {
  return { average: 0, min: 0, max: 0 };
}

export const Timings: MessageFns<Timings> = {
  encode(message: Timings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.average !== 0) {
      writer.uint32(13).float(message.average);
    }
    if (message.min !== 0) {
      writer.uint32(21).float(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(29).float(message.max);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Timings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.average = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.max = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Timings {
    return {
      average: isSet(object.average) ? globalThis.Number(object.average) : 0,
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
    };
  },

  toJSON(message: Timings): unknown {
    const obj: any = {};
    if (message.average !== 0) {
      obj.average = message.average;
    }
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    return obj;
  },

  create(base?: DeepPartial<Timings>): Timings {
    return Timings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Timings>): Timings {
    const message = createBaseTimings();
    message.average = object.average ?? 0;
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    return message;
  },
};

function createBaseCpuTimings(): CpuTimings {
  return { main: undefined, threads: [] };
}

export const CpuTimings: MessageFns<CpuTimings> = {
  encode(message: CpuTimings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.main !== undefined) {
      Timings.encode(message.main, writer.uint32(10).fork()).join();
    }
    for (const v of message.threads) {
      Timings.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CpuTimings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCpuTimings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.main = Timings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.threads.push(Timings.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CpuTimings {
    return {
      main: isSet(object.main) ? Timings.fromJSON(object.main) : undefined,
      threads: globalThis.Array.isArray(object?.threads) ? object.threads.map((e: any) => Timings.fromJSON(e)) : [],
    };
  },

  toJSON(message: CpuTimings): unknown {
    const obj: any = {};
    if (message.main !== undefined) {
      obj.main = Timings.toJSON(message.main);
    }
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => Timings.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CpuTimings>): CpuTimings {
    return CpuTimings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CpuTimings>): CpuTimings {
    const message = createBaseCpuTimings();
    message.main = (object.main !== undefined && object.main !== null) ? Timings.fromPartial(object.main) : undefined;
    message.threads = object.threads?.map((e) => Timings.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTimingResponse(): TimingResponse {
  return { status: undefined, timings: undefined };
}

export const TimingResponse: MessageFns<TimingResponse> = {
  encode(message: TimingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.timings !== undefined) {
      Timings.encode(message.timings, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timings = Timings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimingResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      timings: isSet(object.timings) ? Timings.fromJSON(object.timings) : undefined,
    };
  },

  toJSON(message: TimingResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.timings !== undefined) {
      obj.timings = Timings.toJSON(message.timings);
    }
    return obj;
  },

  create(base?: DeepPartial<TimingResponse>): TimingResponse {
    return TimingResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimingResponse>): TimingResponse {
    const message = createBaseTimingResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.timings = (object.timings !== undefined && object.timings !== null)
      ? Timings.fromPartial(object.timings)
      : undefined;
    return message;
  },
};

function createBaseNoteOnRequest(): NoteOnRequest {
  return { track: undefined, channel: 0, note: 0, velocity: 0 };
}

export const NoteOnRequest: MessageFns<NoteOnRequest> = {
  encode(message: NoteOnRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.note !== 0) {
      writer.uint32(24).int32(message.note);
    }
    if (message.velocity !== 0) {
      writer.uint32(37).float(message.velocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteOnRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteOnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.note = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.velocity = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteOnRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      note: isSet(object.note) ? globalThis.Number(object.note) : 0,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
    };
  },

  toJSON(message: NoteOnRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.note !== 0) {
      obj.note = Math.round(message.note);
    }
    if (message.velocity !== 0) {
      obj.velocity = message.velocity;
    }
    return obj;
  },

  create(base?: DeepPartial<NoteOnRequest>): NoteOnRequest {
    return NoteOnRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteOnRequest>): NoteOnRequest {
    const message = createBaseNoteOnRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.note = object.note ?? 0;
    message.velocity = object.velocity ?? 0;
    return message;
  },
};

function createBaseNoteOffRequest(): NoteOffRequest {
  return { track: undefined, channel: 0, note: 0, velocity: 0 };
}

export const NoteOffRequest: MessageFns<NoteOffRequest> = {
  encode(message: NoteOffRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.note !== 0) {
      writer.uint32(24).int32(message.note);
    }
    if (message.velocity !== 0) {
      writer.uint32(37).float(message.velocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteOffRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteOffRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.note = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.velocity = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteOffRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      note: isSet(object.note) ? globalThis.Number(object.note) : 0,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
    };
  },

  toJSON(message: NoteOffRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.note !== 0) {
      obj.note = Math.round(message.note);
    }
    if (message.velocity !== 0) {
      obj.velocity = message.velocity;
    }
    return obj;
  },

  create(base?: DeepPartial<NoteOffRequest>): NoteOffRequest {
    return NoteOffRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteOffRequest>): NoteOffRequest {
    const message = createBaseNoteOffRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.note = object.note ?? 0;
    message.velocity = object.velocity ?? 0;
    return message;
  },
};

function createBaseNoteAftertouchRequest(): NoteAftertouchRequest {
  return { track: undefined, channel: 0, note: 0, value: 0 };
}

export const NoteAftertouchRequest: MessageFns<NoteAftertouchRequest> = {
  encode(message: NoteAftertouchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.note !== 0) {
      writer.uint32(24).int32(message.note);
    }
    if (message.value !== 0) {
      writer.uint32(37).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteAftertouchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteAftertouchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.note = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteAftertouchRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      note: isSet(object.note) ? globalThis.Number(object.note) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: NoteAftertouchRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.note !== 0) {
      obj.note = Math.round(message.note);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NoteAftertouchRequest>): NoteAftertouchRequest {
    return NoteAftertouchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteAftertouchRequest>): NoteAftertouchRequest {
    const message = createBaseNoteAftertouchRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.note = object.note ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseNoteModulationRequest(): NoteModulationRequest {
  return { track: undefined, channel: 0, value: 0 };
}

export const NoteModulationRequest: MessageFns<NoteModulationRequest> = {
  encode(message: NoteModulationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteModulationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteModulationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteModulationRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: NoteModulationRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NoteModulationRequest>): NoteModulationRequest {
    return NoteModulationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteModulationRequest>): NoteModulationRequest {
    const message = createBaseNoteModulationRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseTrackType(): TrackType {
  return { type: 0 };
}

export const TrackType: MessageFns<TrackType> = {
  encode(message: TrackType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackType {
    return { type: isSet(object.type) ? trackType_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: TrackType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = trackType_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<TrackType>): TrackType {
    return TrackType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackType>): TrackType {
    const message = createBaseTrackType();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseTrackInfo(): TrackInfo {
  return { id: 0, label: "", name: "", channels: 0, buses: 0, thread: 0, type: undefined, processors: [] };
}

export const TrackInfo: MessageFns<TrackInfo> = {
  encode(message: TrackInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.channels !== 0) {
      writer.uint32(32).int32(message.channels);
    }
    if (message.buses !== 0) {
      writer.uint32(40).int32(message.buses);
    }
    if (message.thread !== 0) {
      writer.uint32(48).int32(message.thread);
    }
    if (message.type !== undefined) {
      TrackType.encode(message.type, writer.uint32(58).fork()).join();
    }
    for (const v of message.processors) {
      ProcessorIdentifier.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channels = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.buses = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.thread = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = TrackType.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processors.push(ProcessorIdentifier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
      buses: isSet(object.buses) ? globalThis.Number(object.buses) : 0,
      thread: isSet(object.thread) ? globalThis.Number(object.thread) : 0,
      type: isSet(object.type) ? TrackType.fromJSON(object.type) : undefined,
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => ProcessorIdentifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrackInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    if (message.buses !== 0) {
      obj.buses = Math.round(message.buses);
    }
    if (message.thread !== 0) {
      obj.thread = Math.round(message.thread);
    }
    if (message.type !== undefined) {
      obj.type = TrackType.toJSON(message.type);
    }
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => ProcessorIdentifier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TrackInfo>): TrackInfo {
    return TrackInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackInfo>): TrackInfo {
    const message = createBaseTrackInfo();
    message.id = object.id ?? 0;
    message.label = object.label ?? "";
    message.name = object.name ?? "";
    message.channels = object.channels ?? 0;
    message.buses = object.buses ?? 0;
    message.thread = object.thread ?? 0;
    message.type = (object.type !== undefined && object.type !== null) ? TrackType.fromPartial(object.type) : undefined;
    message.processors = object.processors?.map((e) => ProcessorIdentifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrackInfoResponse(): TrackInfoResponse {
  return { status: undefined, info: undefined };
}

export const TrackInfoResponse: MessageFns<TrackInfoResponse> = {
  encode(message: TrackInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.info !== undefined) {
      TrackInfo.encode(message.info, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.info = TrackInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackInfoResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      info: isSet(object.info) ? TrackInfo.fromJSON(object.info) : undefined,
    };
  },

  toJSON(message: TrackInfoResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.info !== undefined) {
      obj.info = TrackInfo.toJSON(message.info);
    }
    return obj;
  },

  create(base?: DeepPartial<TrackInfoResponse>): TrackInfoResponse {
    return TrackInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackInfoResponse>): TrackInfoResponse {
    const message = createBaseTrackInfoResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.info = (object.info !== undefined && object.info !== null) ? TrackInfo.fromPartial(object.info) : undefined;
    return message;
  },
};

function createBaseTrackInfoList(): TrackInfoList {
  return { tracks: [] };
}

export const TrackInfoList: MessageFns<TrackInfoList> = {
  encode(message: TrackInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tracks) {
      TrackInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tracks.push(TrackInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackInfoList {
    return {
      tracks: globalThis.Array.isArray(object?.tracks) ? object.tracks.map((e: any) => TrackInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: TrackInfoList): unknown {
    const obj: any = {};
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => TrackInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TrackInfoList>): TrackInfoList {
    return TrackInfoList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackInfoList>): TrackInfoList {
    const message = createBaseTrackInfoList();
    message.tracks = object.tracks?.map((e) => TrackInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessorInfo(): ProcessorInfo {
  return { id: 0, label: "", name: "", parameterCount: 0, programCount: 0 };
}

export const ProcessorInfo: MessageFns<ProcessorInfo> = {
  encode(message: ProcessorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.parameterCount !== 0) {
      writer.uint32(32).int32(message.parameterCount);
    }
    if (message.programCount !== 0) {
      writer.uint32(40).int32(message.programCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parameterCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.programCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parameterCount: isSet(object.parameterCount) ? globalThis.Number(object.parameterCount) : 0,
      programCount: isSet(object.programCount) ? globalThis.Number(object.programCount) : 0,
    };
  },

  toJSON(message: ProcessorInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parameterCount !== 0) {
      obj.parameterCount = Math.round(message.parameterCount);
    }
    if (message.programCount !== 0) {
      obj.programCount = Math.round(message.programCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorInfo>): ProcessorInfo {
    return ProcessorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorInfo>): ProcessorInfo {
    const message = createBaseProcessorInfo();
    message.id = object.id ?? 0;
    message.label = object.label ?? "";
    message.name = object.name ?? "";
    message.parameterCount = object.parameterCount ?? 0;
    message.programCount = object.programCount ?? 0;
    return message;
  },
};

function createBaseProcessorInfoResponse(): ProcessorInfoResponse {
  return { status: undefined, processor: undefined };
}

export const ProcessorInfoResponse: MessageFns<ProcessorInfoResponse> = {
  encode(message: ProcessorInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.processor !== undefined) {
      ProcessorInfo.encode(message.processor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.processor = ProcessorInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorInfoResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      processor: isSet(object.processor) ? ProcessorInfo.fromJSON(object.processor) : undefined,
    };
  },

  toJSON(message: ProcessorInfoResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.processor !== undefined) {
      obj.processor = ProcessorInfo.toJSON(message.processor);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorInfoResponse>): ProcessorInfoResponse {
    return ProcessorInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorInfoResponse>): ProcessorInfoResponse {
    const message = createBaseProcessorInfoResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorInfo.fromPartial(object.processor)
      : undefined;
    return message;
  },
};

function createBaseProcessorInfoList(): ProcessorInfoList {
  return { processors: [] };
}

export const ProcessorInfoList: MessageFns<ProcessorInfoList> = {
  encode(message: ProcessorInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.processors) {
      ProcessorInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processors.push(ProcessorInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorInfoList {
    return {
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => ProcessorInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessorInfoList): unknown {
    const obj: any = {};
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => ProcessorInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorInfoList>): ProcessorInfoList {
    return ProcessorInfoList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorInfoList>): ProcessorInfoList {
    const message = createBaseProcessorInfoList();
    message.processors = object.processors?.map((e) => ProcessorInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessorInfoListResponse(): ProcessorInfoListResponse {
  return { status: undefined, processors: [] };
}

export const ProcessorInfoListResponse: MessageFns<ProcessorInfoListResponse> = {
  encode(message: ProcessorInfoListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.processors) {
      ProcessorInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInfoListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorInfoListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.processors.push(ProcessorInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorInfoListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => ProcessorInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessorInfoListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => ProcessorInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorInfoListResponse>): ProcessorInfoListResponse {
    return ProcessorInfoListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorInfoListResponse>): ProcessorInfoListResponse {
    const message = createBaseProcessorInfoListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.processors = object.processors?.map((e) => ProcessorInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProgramIdentifier(): ProgramIdentifier {
  return { program: 0 };
}

export const ProgramIdentifier: MessageFns<ProgramIdentifier> = {
  encode(message: ProgramIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== 0) {
      writer.uint32(8).int32(message.program);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.program = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramIdentifier {
    return { program: isSet(object.program) ? globalThis.Number(object.program) : 0 };
  },

  toJSON(message: ProgramIdentifier): unknown {
    const obj: any = {};
    if (message.program !== 0) {
      obj.program = Math.round(message.program);
    }
    return obj;
  },

  create(base?: DeepPartial<ProgramIdentifier>): ProgramIdentifier {
    return ProgramIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProgramIdentifier>): ProgramIdentifier {
    const message = createBaseProgramIdentifier();
    message.program = object.program ?? 0;
    return message;
  },
};

function createBaseProgramIdentifierResponse(): ProgramIdentifierResponse {
  return { status: undefined, program: 0 };
}

export const ProgramIdentifierResponse: MessageFns<ProgramIdentifierResponse> = {
  encode(message: ProgramIdentifierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.program !== 0) {
      writer.uint32(16).int32(message.program);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramIdentifierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramIdentifierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.program = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramIdentifierResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      program: isSet(object.program) ? globalThis.Number(object.program) : 0,
    };
  },

  toJSON(message: ProgramIdentifierResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.program !== 0) {
      obj.program = Math.round(message.program);
    }
    return obj;
  },

  create(base?: DeepPartial<ProgramIdentifierResponse>): ProgramIdentifierResponse {
    return ProgramIdentifierResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProgramIdentifierResponse>): ProgramIdentifierResponse {
    const message = createBaseProgramIdentifierResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.program = object.program ?? 0;
    return message;
  },
};

function createBaseProcessorProgramIdentifier(): ProcessorProgramIdentifier {
  return { processor: undefined, program: 0 };
}

export const ProcessorProgramIdentifier: MessageFns<ProcessorProgramIdentifier> = {
  encode(message: ProcessorProgramIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.program !== 0) {
      writer.uint32(16).int32(message.program);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorProgramIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorProgramIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.program = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorProgramIdentifier {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      program: isSet(object.program) ? globalThis.Number(object.program) : 0,
    };
  },

  toJSON(message: ProcessorProgramIdentifier): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.program !== 0) {
      obj.program = Math.round(message.program);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorProgramIdentifier>): ProcessorProgramIdentifier {
    return ProcessorProgramIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorProgramIdentifier>): ProcessorProgramIdentifier {
    const message = createBaseProcessorProgramIdentifier();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.program = object.program ?? 0;
    return message;
  },
};

function createBaseProgramInfo(): ProgramInfo {
  return { id: undefined, name: "" };
}

export const ProgramInfo: MessageFns<ProgramInfo> = {
  encode(message: ProgramInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ProgramIdentifier.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = ProgramIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramInfo {
    return {
      id: isSet(object.id) ? ProgramIdentifier.fromJSON(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: ProgramInfo): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ProgramIdentifier.toJSON(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ProgramInfo>): ProgramInfo {
    return ProgramInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProgramInfo>): ProgramInfo {
    const message = createBaseProgramInfo();
    message.id = (object.id !== undefined && object.id !== null) ? ProgramIdentifier.fromPartial(object.id) : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseProgramInfoList(): ProgramInfoList {
  return { programs: [] };
}

export const ProgramInfoList: MessageFns<ProgramInfoList> = {
  encode(message: ProgramInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.programs) {
      ProgramInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programs.push(ProgramInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramInfoList {
    return {
      programs: globalThis.Array.isArray(object?.programs)
        ? object.programs.map((e: any) => ProgramInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProgramInfoList): unknown {
    const obj: any = {};
    if (message.programs?.length) {
      obj.programs = message.programs.map((e) => ProgramInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProgramInfoList>): ProgramInfoList {
    return ProgramInfoList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProgramInfoList>): ProgramInfoList {
    const message = createBaseProgramInfoList();
    message.programs = object.programs?.map((e) => ProgramInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProgramInfoListResponse(): ProgramInfoListResponse {
  return { status: undefined, programs: [] };
}

export const ProgramInfoListResponse: MessageFns<ProgramInfoListResponse> = {
  encode(message: ProgramInfoListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.programs) {
      ProgramInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramInfoListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramInfoListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.programs.push(ProgramInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramInfoListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      programs: globalThis.Array.isArray(object?.programs)
        ? object.programs.map((e: any) => ProgramInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProgramInfoListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.programs?.length) {
      obj.programs = message.programs.map((e) => ProgramInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProgramInfoListResponse>): ProgramInfoListResponse {
    return ProgramInfoListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProgramInfoListResponse>): ProgramInfoListResponse {
    const message = createBaseProgramInfoListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.programs = object.programs?.map((e) => ProgramInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessorProgramSetRequest(): ProcessorProgramSetRequest {
  return { processor: undefined, program: undefined };
}

export const ProcessorProgramSetRequest: MessageFns<ProcessorProgramSetRequest> = {
  encode(message: ProcessorProgramSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.program !== undefined) {
      ProgramIdentifier.encode(message.program, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorProgramSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorProgramSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.program = ProgramIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorProgramSetRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      program: isSet(object.program) ? ProgramIdentifier.fromJSON(object.program) : undefined,
    };
  },

  toJSON(message: ProcessorProgramSetRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.program !== undefined) {
      obj.program = ProgramIdentifier.toJSON(message.program);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorProgramSetRequest>): ProcessorProgramSetRequest {
    return ProcessorProgramSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorProgramSetRequest>): ProcessorProgramSetRequest {
    const message = createBaseProcessorProgramSetRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.program = (object.program !== undefined && object.program !== null)
      ? ProgramIdentifier.fromPartial(object.program)
      : undefined;
    return message;
  },
};

function createBaseProcessorBypassStateSetRequest(): ProcessorBypassStateSetRequest {
  return { processor: undefined, value: false };
}

export const ProcessorBypassStateSetRequest: MessageFns<ProcessorBypassStateSetRequest> = {
  encode(message: ProcessorBypassStateSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorBypassStateSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorBypassStateSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorBypassStateSetRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: ProcessorBypassStateSetRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorBypassStateSetRequest>): ProcessorBypassStateSetRequest {
    return ProcessorBypassStateSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorBypassStateSetRequest>): ProcessorBypassStateSetRequest {
    const message = createBaseProcessorBypassStateSetRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseProcessorState(): ProcessorState {
  return { programId: undefined, bypassed: undefined, properties: [], parameters: [], binaryData: new Uint8Array(0) };
}

export const ProcessorState: MessageFns<ProcessorState> = {
  encode(message: ProcessorState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programId !== undefined) {
      OptionalIntValue.encode(message.programId, writer.uint32(10).fork()).join();
    }
    if (message.bypassed !== undefined) {
      OptionalBoolValue.encode(message.bypassed, writer.uint32(18).fork()).join();
    }
    for (const v of message.properties) {
      PropertyValue.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.parameters) {
      ParameterValue.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.binaryData.length !== 0) {
      writer.uint32(42).bytes(message.binaryData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programId = OptionalIntValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bypassed = OptionalBoolValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.properties.push(PropertyValue.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameters.push(ParameterValue.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.binaryData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorState {
    return {
      programId: isSet(object.programId) ? OptionalIntValue.fromJSON(object.programId) : undefined,
      bypassed: isSet(object.bypassed) ? OptionalBoolValue.fromJSON(object.bypassed) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertyValue.fromJSON(e))
        : [],
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterValue.fromJSON(e))
        : [],
      binaryData: isSet(object.binaryData) ? bytesFromBase64(object.binaryData) : new Uint8Array(0),
    };
  },

  toJSON(message: ProcessorState): unknown {
    const obj: any = {};
    if (message.programId !== undefined) {
      obj.programId = OptionalIntValue.toJSON(message.programId);
    }
    if (message.bypassed !== undefined) {
      obj.bypassed = OptionalBoolValue.toJSON(message.bypassed);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertyValue.toJSON(e));
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ParameterValue.toJSON(e));
    }
    if (message.binaryData.length !== 0) {
      obj.binaryData = base64FromBytes(message.binaryData);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorState>): ProcessorState {
    return ProcessorState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorState>): ProcessorState {
    const message = createBaseProcessorState();
    message.programId = (object.programId !== undefined && object.programId !== null)
      ? OptionalIntValue.fromPartial(object.programId)
      : undefined;
    message.bypassed = (object.bypassed !== undefined && object.bypassed !== null)
      ? OptionalBoolValue.fromPartial(object.bypassed)
      : undefined;
    message.properties = object.properties?.map((e) => PropertyValue.fromPartial(e)) || [];
    message.parameters = object.parameters?.map((e) => ParameterValue.fromPartial(e)) || [];
    message.binaryData = object.binaryData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProcessorStateResponse(): ProcessorStateResponse {
  return { status: undefined, state: undefined };
}

export const ProcessorStateResponse: MessageFns<ProcessorStateResponse> = {
  encode(message: ProcessorStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.state !== undefined) {
      ProcessorState.encode(message.state, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = ProcessorState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorStateResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      state: isSet(object.state) ? ProcessorState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: ProcessorStateResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.state !== undefined) {
      obj.state = ProcessorState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorStateResponse>): ProcessorStateResponse {
    return ProcessorStateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorStateResponse>): ProcessorStateResponse {
    const message = createBaseProcessorStateResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ProcessorState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseProcessorStateSetRequest(): ProcessorStateSetRequest {
  return { processor: undefined, state: undefined };
}

export const ProcessorStateSetRequest: MessageFns<ProcessorStateSetRequest> = {
  encode(message: ProcessorStateSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.state !== undefined) {
      ProcessorState.encode(message.state, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorStateSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorStateSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = ProcessorState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorStateSetRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      state: isSet(object.state) ? ProcessorState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: ProcessorStateSetRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.state !== undefined) {
      obj.state = ProcessorState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorStateSetRequest>): ProcessorStateSetRequest {
    return ProcessorStateSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorStateSetRequest>): ProcessorStateSetRequest {
    const message = createBaseProcessorStateSetRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ProcessorState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseParameterInfo(): ParameterInfo {
  return {
    id: 0,
    type: undefined,
    label: "",
    name: "",
    unit: "",
    automatable: false,
    minDomainValue: 0,
    maxDomainValue: 0,
  };
}

export const ParameterInfo: MessageFns<ParameterInfo> = {
  encode(message: ParameterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.type !== undefined) {
      ParameterType.encode(message.type, writer.uint32(18).fork()).join();
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.unit !== "") {
      writer.uint32(42).string(message.unit);
    }
    if (message.automatable !== false) {
      writer.uint32(48).bool(message.automatable);
    }
    if (message.minDomainValue !== 0) {
      writer.uint32(61).float(message.minDomainValue);
    }
    if (message.maxDomainValue !== 0) {
      writer.uint32(69).float(message.maxDomainValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = ParameterType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.automatable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.minDomainValue = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.maxDomainValue = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? ParameterType.fromJSON(object.type) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
      automatable: isSet(object.automatable) ? globalThis.Boolean(object.automatable) : false,
      minDomainValue: isSet(object.minDomainValue) ? globalThis.Number(object.minDomainValue) : 0,
      maxDomainValue: isSet(object.maxDomainValue) ? globalThis.Number(object.maxDomainValue) : 0,
    };
  },

  toJSON(message: ParameterInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== undefined) {
      obj.type = ParameterType.toJSON(message.type);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    if (message.automatable !== false) {
      obj.automatable = message.automatable;
    }
    if (message.minDomainValue !== 0) {
      obj.minDomainValue = message.minDomainValue;
    }
    if (message.maxDomainValue !== 0) {
      obj.maxDomainValue = message.maxDomainValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterInfo>): ParameterInfo {
    return ParameterInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterInfo>): ParameterInfo {
    const message = createBaseParameterInfo();
    message.id = object.id ?? 0;
    message.type = (object.type !== undefined && object.type !== null)
      ? ParameterType.fromPartial(object.type)
      : undefined;
    message.label = object.label ?? "";
    message.name = object.name ?? "";
    message.unit = object.unit ?? "";
    message.automatable = object.automatable ?? false;
    message.minDomainValue = object.minDomainValue ?? 0;
    message.maxDomainValue = object.maxDomainValue ?? 0;
    return message;
  },
};

function createBaseParameterInfoResponse(): ParameterInfoResponse {
  return { status: undefined, info: undefined };
}

export const ParameterInfoResponse: MessageFns<ParameterInfoResponse> = {
  encode(message: ParameterInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.info !== undefined) {
      ParameterInfo.encode(message.info, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.info = ParameterInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterInfoResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      info: isSet(object.info) ? ParameterInfo.fromJSON(object.info) : undefined,
    };
  },

  toJSON(message: ParameterInfoResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.info !== undefined) {
      obj.info = ParameterInfo.toJSON(message.info);
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterInfoResponse>): ParameterInfoResponse {
    return ParameterInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterInfoResponse>): ParameterInfoResponse {
    const message = createBaseParameterInfoResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.info = (object.info !== undefined && object.info !== null)
      ? ParameterInfo.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBaseParameterInfoList(): ParameterInfoList {
  return { parameters: [] };
}

export const ParameterInfoList: MessageFns<ParameterInfoList> = {
  encode(message: ParameterInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameters) {
      ParameterInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameters.push(ParameterInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterInfoList {
    return {
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ParameterInfoList): unknown {
    const obj: any = {};
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ParameterInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterInfoList>): ParameterInfoList {
    return ParameterInfoList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterInfoList>): ParameterInfoList {
    const message = createBaseParameterInfoList();
    message.parameters = object.parameters?.map((e) => ParameterInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParameterInfoListResponse(): ParameterInfoListResponse {
  return { status: undefined, parameters: [] };
}

export const ParameterInfoListResponse: MessageFns<ParameterInfoListResponse> = {
  encode(message: ParameterInfoListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.parameters) {
      ParameterInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterInfoListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterInfoListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parameters.push(ParameterInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterInfoListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ParameterInfoListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ParameterInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterInfoListResponse>): ParameterInfoListResponse {
    return ParameterInfoListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterInfoListResponse>): ParameterInfoListResponse {
    const message = createBaseParameterInfoListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.parameters = object.parameters?.map((e) => ParameterInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParameterIdRequest(): ParameterIdRequest {
  return { processor: undefined, ParameterName: "" };
}

export const ParameterIdRequest: MessageFns<ParameterIdRequest> = {
  encode(message: ParameterIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.ParameterName !== "") {
      writer.uint32(18).string(message.ParameterName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ParameterName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterIdRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      ParameterName: isSet(object.ParameterName) ? globalThis.String(object.ParameterName) : "",
    };
  },

  toJSON(message: ParameterIdRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.ParameterName !== "") {
      obj.ParameterName = message.ParameterName;
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterIdRequest>): ParameterIdRequest {
    return ParameterIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterIdRequest>): ParameterIdRequest {
    const message = createBaseParameterIdRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.ParameterName = object.ParameterName ?? "";
    return message;
  },
};

function createBaseParameterValue(): ParameterValue {
  return { parameter: undefined, value: 0 };
}

export const ParameterValue: MessageFns<ParameterValue> = {
  encode(message: ParameterValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterValue {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ParameterValue): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterValue>): ParameterValue {
    return ParameterValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterValue>): ParameterValue {
    const message = createBaseParameterValue();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseParameterUpdate(): ParameterUpdate {
  return { parameter: undefined, normalizedValue: 0, domainValue: 0, formattedValue: "" };
}

export const ParameterUpdate: MessageFns<ParameterUpdate> = {
  encode(message: ParameterUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.normalizedValue !== 0) {
      writer.uint32(21).float(message.normalizedValue);
    }
    if (message.domainValue !== 0) {
      writer.uint32(29).float(message.domainValue);
    }
    if (message.formattedValue !== "") {
      writer.uint32(34).string(message.formattedValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.normalizedValue = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.domainValue = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.formattedValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterUpdate {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      normalizedValue: isSet(object.normalizedValue) ? globalThis.Number(object.normalizedValue) : 0,
      domainValue: isSet(object.domainValue) ? globalThis.Number(object.domainValue) : 0,
      formattedValue: isSet(object.formattedValue) ? globalThis.String(object.formattedValue) : "",
    };
  },

  toJSON(message: ParameterUpdate): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.normalizedValue !== 0) {
      obj.normalizedValue = message.normalizedValue;
    }
    if (message.domainValue !== 0) {
      obj.domainValue = message.domainValue;
    }
    if (message.formattedValue !== "") {
      obj.formattedValue = message.formattedValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterUpdate>): ParameterUpdate {
    return ParameterUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterUpdate>): ParameterUpdate {
    const message = createBaseParameterUpdate();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.normalizedValue = object.normalizedValue ?? 0;
    message.domainValue = object.domainValue ?? 0;
    message.formattedValue = object.formattedValue ?? "";
    return message;
  },
};

function createBasePropertyInfo(): PropertyInfo {
  return { id: 0, name: "", label: "" };
}

export const PropertyInfo: MessageFns<PropertyInfo> = {
  encode(message: PropertyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: PropertyInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyInfo>): PropertyInfo {
    return PropertyInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyInfo>): PropertyInfo {
    const message = createBasePropertyInfo();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBasePropertyInfoResponse(): PropertyInfoResponse {
  return { status: undefined, info: undefined };
}

export const PropertyInfoResponse: MessageFns<PropertyInfoResponse> = {
  encode(message: PropertyInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.info !== undefined) {
      PropertyInfo.encode(message.info, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.info = PropertyInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyInfoResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      info: isSet(object.info) ? PropertyInfo.fromJSON(object.info) : undefined,
    };
  },

  toJSON(message: PropertyInfoResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.info !== undefined) {
      obj.info = PropertyInfo.toJSON(message.info);
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyInfoResponse>): PropertyInfoResponse {
    return PropertyInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyInfoResponse>): PropertyInfoResponse {
    const message = createBasePropertyInfoResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.info = (object.info !== undefined && object.info !== null)
      ? PropertyInfo.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBasePropertyInfoList(): PropertyInfoList {
  return { properties: [] };
}

export const PropertyInfoList: MessageFns<PropertyInfoList> = {
  encode(message: PropertyInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.properties) {
      PropertyInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.properties.push(PropertyInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyInfoList {
    return {
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertyInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyInfoList): unknown {
    const obj: any = {};
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertyInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyInfoList>): PropertyInfoList {
    return PropertyInfoList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyInfoList>): PropertyInfoList {
    const message = createBasePropertyInfoList();
    message.properties = object.properties?.map((e) => PropertyInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertyInfoListResponse(): PropertyInfoListResponse {
  return { status: undefined, properties: [] };
}

export const PropertyInfoListResponse: MessageFns<PropertyInfoListResponse> = {
  encode(message: PropertyInfoListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.properties) {
      PropertyInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyInfoListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyInfoListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.properties.push(PropertyInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyInfoListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertyInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyInfoListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertyInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyInfoListResponse>): PropertyInfoListResponse {
    return PropertyInfoListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyInfoListResponse>): PropertyInfoListResponse {
    const message = createBasePropertyInfoListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.properties = object.properties?.map((e) => PropertyInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertyValue(): PropertyValue {
  return { property: undefined, value: "" };
}

export const PropertyValue: MessageFns<PropertyValue> = {
  encode(message: PropertyValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      PropertyIdentifier.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.property = PropertyIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyValue {
    return {
      property: isSet(object.property) ? PropertyIdentifier.fromJSON(object.property) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PropertyValue): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = PropertyIdentifier.toJSON(message.property);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyValue>): PropertyValue {
    return PropertyValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyValue>): PropertyValue {
    const message = createBasePropertyValue();
    message.property = (object.property !== undefined && object.property !== null)
      ? PropertyIdentifier.fromPartial(object.property)
      : undefined;
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePropertyIdRequest(): PropertyIdRequest {
  return { processor: undefined, propertyName: "" };
}

export const PropertyIdRequest: MessageFns<PropertyIdRequest> = {
  encode(message: PropertyIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.propertyName !== "") {
      writer.uint32(18).string(message.propertyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.propertyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyIdRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      propertyName: isSet(object.propertyName) ? globalThis.String(object.propertyName) : "",
    };
  },

  toJSON(message: PropertyIdRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.propertyName !== "") {
      obj.propertyName = message.propertyName;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyIdRequest>): PropertyIdRequest {
    return PropertyIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyIdRequest>): PropertyIdRequest {
    const message = createBasePropertyIdRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.propertyName = object.propertyName ?? "";
    return message;
  },
};

function createBasePluginType(): PluginType {
  return { type: 0 };
}

export const PluginType: MessageFns<PluginType> = {
  encode(message: PluginType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginType {
    return { type: isSet(object.type) ? pluginType_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: PluginType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = pluginType_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<PluginType>): PluginType {
    return PluginType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginType>): PluginType {
    const message = createBasePluginType();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseProcessorPosition(): ProcessorPosition {
  return { addToBack: false, beforeProcessor: undefined };
}

export const ProcessorPosition: MessageFns<ProcessorPosition> = {
  encode(message: ProcessorPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addToBack !== false) {
      writer.uint32(8).bool(message.addToBack);
    }
    if (message.beforeProcessor !== undefined) {
      ProcessorIdentifier.encode(message.beforeProcessor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.addToBack = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeProcessor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorPosition {
    return {
      addToBack: isSet(object.addToBack) ? globalThis.Boolean(object.addToBack) : false,
      beforeProcessor: isSet(object.beforeProcessor) ? ProcessorIdentifier.fromJSON(object.beforeProcessor) : undefined,
    };
  },

  toJSON(message: ProcessorPosition): unknown {
    const obj: any = {};
    if (message.addToBack !== false) {
      obj.addToBack = message.addToBack;
    }
    if (message.beforeProcessor !== undefined) {
      obj.beforeProcessor = ProcessorIdentifier.toJSON(message.beforeProcessor);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorPosition>): ProcessorPosition {
    return ProcessorPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorPosition>): ProcessorPosition {
    const message = createBaseProcessorPosition();
    message.addToBack = object.addToBack ?? false;
    message.beforeProcessor = (object.beforeProcessor !== undefined && object.beforeProcessor !== null)
      ? ProcessorIdentifier.fromPartial(object.beforeProcessor)
      : undefined;
    return message;
  },
};

function createBaseCreateTrackRequest(): CreateTrackRequest {
  return { name: "", channels: 0, thread: undefined };
}

export const CreateTrackRequest: MessageFns<CreateTrackRequest> = {
  encode(message: CreateTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.channels !== 0) {
      writer.uint32(16).int32(message.channels);
    }
    if (message.thread !== undefined) {
      OptionalIntValue.encode(message.thread, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channels = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thread = OptionalIntValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTrackRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
      thread: isSet(object.thread) ? OptionalIntValue.fromJSON(object.thread) : undefined,
    };
  },

  toJSON(message: CreateTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    if (message.thread !== undefined) {
      obj.thread = OptionalIntValue.toJSON(message.thread);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTrackRequest>): CreateTrackRequest {
    return CreateTrackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTrackRequest>): CreateTrackRequest {
    const message = createBaseCreateTrackRequest();
    message.name = object.name ?? "";
    message.channels = object.channels ?? 0;
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? OptionalIntValue.fromPartial(object.thread)
      : undefined;
    return message;
  },
};

function createBaseCreateMultibusTrackRequest(): CreateMultibusTrackRequest {
  return { name: "", buses: 0, thread: undefined };
}

export const CreateMultibusTrackRequest: MessageFns<CreateMultibusTrackRequest> = {
  encode(message: CreateMultibusTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.buses !== 0) {
      writer.uint32(16).int32(message.buses);
    }
    if (message.thread !== undefined) {
      OptionalIntValue.encode(message.thread, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMultibusTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMultibusTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.buses = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thread = OptionalIntValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMultibusTrackRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      buses: isSet(object.buses) ? globalThis.Number(object.buses) : 0,
      thread: isSet(object.thread) ? OptionalIntValue.fromJSON(object.thread) : undefined,
    };
  },

  toJSON(message: CreateMultibusTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.buses !== 0) {
      obj.buses = Math.round(message.buses);
    }
    if (message.thread !== undefined) {
      obj.thread = OptionalIntValue.toJSON(message.thread);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateMultibusTrackRequest>): CreateMultibusTrackRequest {
    return CreateMultibusTrackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateMultibusTrackRequest>): CreateMultibusTrackRequest {
    const message = createBaseCreateMultibusTrackRequest();
    message.name = object.name ?? "";
    message.buses = object.buses ?? 0;
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? OptionalIntValue.fromPartial(object.thread)
      : undefined;
    return message;
  },
};

function createBaseCreatePreTrackRequest(): CreatePreTrackRequest {
  return { name: "" };
}

export const CreatePreTrackRequest: MessageFns<CreatePreTrackRequest> = {
  encode(message: CreatePreTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePreTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePreTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePreTrackRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreatePreTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePreTrackRequest>): CreatePreTrackRequest {
    return CreatePreTrackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePreTrackRequest>): CreatePreTrackRequest {
    const message = createBaseCreatePreTrackRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreatePostTrackRequest(): CreatePostTrackRequest {
  return { name: "" };
}

export const CreatePostTrackRequest: MessageFns<CreatePostTrackRequest> = {
  encode(message: CreatePostTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePostTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePostTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePostTrackRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreatePostTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePostTrackRequest>): CreatePostTrackRequest {
    return CreatePostTrackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePostTrackRequest>): CreatePostTrackRequest {
    const message = createBaseCreatePostTrackRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateProcessorRequest(): CreateProcessorRequest {
  return { name: "", uid: "", path: "", type: undefined, track: undefined, position: undefined };
}

export const CreateProcessorRequest: MessageFns<CreateProcessorRequest> = {
  encode(message: CreateProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.type !== undefined) {
      PluginType.encode(message.type, writer.uint32(34).fork()).join();
    }
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(42).fork()).join();
    }
    if (message.position !== undefined) {
      ProcessorPosition.encode(message.position, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = PluginType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.position = ProcessorPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProcessorRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      type: isSet(object.type) ? PluginType.fromJSON(object.type) : undefined,
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      position: isSet(object.position) ? ProcessorPosition.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: CreateProcessorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.type !== undefined) {
      obj.type = PluginType.toJSON(message.type);
    }
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.position !== undefined) {
      obj.position = ProcessorPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateProcessorRequest>): CreateProcessorRequest {
    return CreateProcessorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateProcessorRequest>): CreateProcessorRequest {
    const message = createBaseCreateProcessorRequest();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.path = object.path ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? PluginType.fromPartial(object.type)
      : undefined;
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? ProcessorPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseMoveProcessorRequest(): MoveProcessorRequest {
  return { processor: undefined, sourceTrack: undefined, destTrack: undefined, position: undefined };
}

export const MoveProcessorRequest: MessageFns<MoveProcessorRequest> = {
  encode(message: MoveProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.sourceTrack !== undefined) {
      TrackIdentifier.encode(message.sourceTrack, writer.uint32(18).fork()).join();
    }
    if (message.destTrack !== undefined) {
      TrackIdentifier.encode(message.destTrack, writer.uint32(26).fork()).join();
    }
    if (message.position !== undefined) {
      ProcessorPosition.encode(message.position, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceTrack = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destTrack = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = ProcessorPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveProcessorRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      sourceTrack: isSet(object.sourceTrack) ? TrackIdentifier.fromJSON(object.sourceTrack) : undefined,
      destTrack: isSet(object.destTrack) ? TrackIdentifier.fromJSON(object.destTrack) : undefined,
      position: isSet(object.position) ? ProcessorPosition.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: MoveProcessorRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.sourceTrack !== undefined) {
      obj.sourceTrack = TrackIdentifier.toJSON(message.sourceTrack);
    }
    if (message.destTrack !== undefined) {
      obj.destTrack = TrackIdentifier.toJSON(message.destTrack);
    }
    if (message.position !== undefined) {
      obj.position = ProcessorPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<MoveProcessorRequest>): MoveProcessorRequest {
    return MoveProcessorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveProcessorRequest>): MoveProcessorRequest {
    const message = createBaseMoveProcessorRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.sourceTrack = (object.sourceTrack !== undefined && object.sourceTrack !== null)
      ? TrackIdentifier.fromPartial(object.sourceTrack)
      : undefined;
    message.destTrack = (object.destTrack !== undefined && object.destTrack !== null)
      ? TrackIdentifier.fromPartial(object.destTrack)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? ProcessorPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseDeleteProcessorRequest(): DeleteProcessorRequest {
  return { processor: undefined, track: undefined };
}

export const DeleteProcessorRequest: MessageFns<DeleteProcessorRequest> = {
  encode(message: DeleteProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProcessorRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
    };
  },

  toJSON(message: DeleteProcessorRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteProcessorRequest>): DeleteProcessorRequest {
    return DeleteProcessorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteProcessorRequest>): DeleteProcessorRequest {
    const message = createBaseDeleteProcessorRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    return message;
  },
};

function createBaseParameterNotificationBlocklist(): ParameterNotificationBlocklist {
  return { parameters: [] };
}

export const ParameterNotificationBlocklist: MessageFns<ParameterNotificationBlocklist> = {
  encode(message: ParameterNotificationBlocklist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameters) {
      ParameterIdentifier.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterNotificationBlocklist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterNotificationBlocklist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameters.push(ParameterIdentifier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterNotificationBlocklist {
    return {
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterIdentifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ParameterNotificationBlocklist): unknown {
    const obj: any = {};
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ParameterIdentifier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterNotificationBlocklist>): ParameterNotificationBlocklist {
    return ParameterNotificationBlocklist.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterNotificationBlocklist>): ParameterNotificationBlocklist {
    const message = createBaseParameterNotificationBlocklist();
    message.parameters = object.parameters?.map((e) => ParameterIdentifier.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertyNotificationBlocklist(): PropertyNotificationBlocklist {
  return { properties: [] };
}

export const PropertyNotificationBlocklist: MessageFns<PropertyNotificationBlocklist> = {
  encode(message: PropertyNotificationBlocklist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.properties) {
      PropertyIdentifier.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyNotificationBlocklist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyNotificationBlocklist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.properties.push(PropertyIdentifier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyNotificationBlocklist {
    return {
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertyIdentifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyNotificationBlocklist): unknown {
    const obj: any = {};
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertyIdentifier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyNotificationBlocklist>): PropertyNotificationBlocklist {
    return PropertyNotificationBlocklist.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyNotificationBlocklist>): PropertyNotificationBlocklist {
    const message = createBasePropertyNotificationBlocklist();
    message.properties = object.properties?.map((e) => PropertyIdentifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiChannel(): MidiChannel {
  return { channel: 0 };
}

export const MidiChannel: MessageFns<MidiChannel> = {
  encode(message: MidiChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiChannel {
    return { channel: isSet(object.channel) ? midiChannel_ChannelFromJSON(object.channel) : 0 };
  },

  toJSON(message: MidiChannel): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = midiChannel_ChannelToJSON(message.channel);
    }
    return obj;
  },

  create(base?: DeepPartial<MidiChannel>): MidiChannel {
    return MidiChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiChannel>): MidiChannel {
    const message = createBaseMidiChannel();
    message.channel = object.channel ?? 0;
    return message;
  },
};

function createBaseAudioConnection(): AudioConnection {
  return { track: undefined, trackChannel: 0, engineChannel: 0 };
}

export const AudioConnection: MessageFns<AudioConnection> = {
  encode(message: AudioConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.trackChannel !== 0) {
      writer.uint32(16).int32(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      writer.uint32(24).int32(message.engineChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trackChannel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.engineChannel = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioConnection {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      trackChannel: isSet(object.trackChannel) ? globalThis.Number(object.trackChannel) : 0,
      engineChannel: isSet(object.engineChannel) ? globalThis.Number(object.engineChannel) : 0,
    };
  },

  toJSON(message: AudioConnection): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.trackChannel !== 0) {
      obj.trackChannel = Math.round(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      obj.engineChannel = Math.round(message.engineChannel);
    }
    return obj;
  },

  create(base?: DeepPartial<AudioConnection>): AudioConnection {
    return AudioConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioConnection>): AudioConnection {
    const message = createBaseAudioConnection();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.trackChannel = object.trackChannel ?? 0;
    message.engineChannel = object.engineChannel ?? 0;
    return message;
  },
};

function createBaseAudioConnectionList(): AudioConnectionList {
  return { connections: [] };
}

export const AudioConnectionList: MessageFns<AudioConnectionList> = {
  encode(message: AudioConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      AudioConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(AudioConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => AudioConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudioConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => AudioConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudioConnectionList>): AudioConnectionList {
    return AudioConnectionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioConnectionList>): AudioConnectionList {
    const message = createBaseAudioConnectionList();
    message.connections = object.connections?.map((e) => AudioConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudioConnectionListResponse(): AudioConnectionListResponse {
  return { status: undefined, connections: [] };
}

export const AudioConnectionListResponse: MessageFns<AudioConnectionListResponse> = {
  encode(message: AudioConnectionListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.connections) {
      AudioConnection.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioConnectionListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioConnectionListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connections.push(AudioConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioConnectionListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => AudioConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudioConnectionListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => AudioConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudioConnectionListResponse>): AudioConnectionListResponse {
    return AudioConnectionListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioConnectionListResponse>): AudioConnectionListResponse {
    const message = createBaseAudioConnectionListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.connections = object.connections?.map((e) => AudioConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCvConnection(): CvConnection {
  return { parameter: undefined, cvPortId: 0 };
}

export const CvConnection: MessageFns<CvConnection> = {
  encode(message: CvConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.cvPortId !== 0) {
      writer.uint32(16).int32(message.cvPortId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CvConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCvConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cvPortId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CvConnection {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      cvPortId: isSet(object.cvPortId) ? globalThis.Number(object.cvPortId) : 0,
    };
  },

  toJSON(message: CvConnection): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.cvPortId !== 0) {
      obj.cvPortId = Math.round(message.cvPortId);
    }
    return obj;
  },

  create(base?: DeepPartial<CvConnection>): CvConnection {
    return CvConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CvConnection>): CvConnection {
    const message = createBaseCvConnection();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.cvPortId = object.cvPortId ?? 0;
    return message;
  },
};

function createBaseCvConnectionList(): CvConnectionList {
  return { connections: [] };
}

export const CvConnectionList: MessageFns<CvConnectionList> = {
  encode(message: CvConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      CvConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CvConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCvConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(CvConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CvConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => CvConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CvConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => CvConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CvConnectionList>): CvConnectionList {
    return CvConnectionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CvConnectionList>): CvConnectionList {
    const message = createBaseCvConnectionList();
    message.connections = object.connections?.map((e) => CvConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCvConnectionListResponse(): CvConnectionListResponse {
  return { status: undefined, connections: [] };
}

export const CvConnectionListResponse: MessageFns<CvConnectionListResponse> = {
  encode(message: CvConnectionListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.connections) {
      CvConnection.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CvConnectionListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCvConnectionListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connections.push(CvConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CvConnectionListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => CvConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CvConnectionListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => CvConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CvConnectionListResponse>): CvConnectionListResponse {
    return CvConnectionListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CvConnectionListResponse>): CvConnectionListResponse {
    const message = createBaseCvConnectionListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.connections = object.connections?.map((e) => CvConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGateConnection(): GateConnection {
  return { processor: undefined, gatePortId: 0, channel: 0, noteNo: 0 };
}

export const GateConnection: MessageFns<GateConnection> = {
  encode(message: GateConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.gatePortId !== 0) {
      writer.uint32(16).int32(message.gatePortId);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.noteNo !== 0) {
      writer.uint32(32).int32(message.noteNo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GateConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gatePortId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noteNo = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GateConnection {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      gatePortId: isSet(object.gatePortId) ? globalThis.Number(object.gatePortId) : 0,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      noteNo: isSet(object.noteNo) ? globalThis.Number(object.noteNo) : 0,
    };
  },

  toJSON(message: GateConnection): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.gatePortId !== 0) {
      obj.gatePortId = Math.round(message.gatePortId);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.noteNo !== 0) {
      obj.noteNo = Math.round(message.noteNo);
    }
    return obj;
  },

  create(base?: DeepPartial<GateConnection>): GateConnection {
    return GateConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GateConnection>): GateConnection {
    const message = createBaseGateConnection();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.gatePortId = object.gatePortId ?? 0;
    message.channel = object.channel ?? 0;
    message.noteNo = object.noteNo ?? 0;
    return message;
  },
};

function createBaseGateConnectionList(): GateConnectionList {
  return { connections: [] };
}

export const GateConnectionList: MessageFns<GateConnectionList> = {
  encode(message: GateConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      GateConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GateConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(GateConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GateConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => GateConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GateConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => GateConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GateConnectionList>): GateConnectionList {
    return GateConnectionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GateConnectionList>): GateConnectionList {
    const message = createBaseGateConnectionList();
    message.connections = object.connections?.map((e) => GateConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGateConnectionListResponse(): GateConnectionListResponse {
  return { status: undefined, connections: [] };
}

export const GateConnectionListResponse: MessageFns<GateConnectionListResponse> = {
  encode(message: GateConnectionListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.connections) {
      GateConnection.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GateConnectionListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateConnectionListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connections.push(GateConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GateConnectionListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => GateConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GateConnectionListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => GateConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GateConnectionListResponse>): GateConnectionListResponse {
    return GateConnectionListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GateConnectionListResponse>): GateConnectionListResponse {
    const message = createBaseGateConnectionListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.connections = object.connections?.map((e) => GateConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiKbdConnection(): MidiKbdConnection {
  return { track: undefined, channel: undefined, port: 0, rawMidi: false };
}

export const MidiKbdConnection: MessageFns<MidiKbdConnection> = {
  encode(message: MidiKbdConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.rawMidi !== false) {
      writer.uint32(56).bool(message.rawMidi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiKbdConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiKbdConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rawMidi = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiKbdConnection {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      rawMidi: isSet(object.rawMidi) ? globalThis.Boolean(object.rawMidi) : false,
    };
  },

  toJSON(message: MidiKbdConnection): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.rawMidi !== false) {
      obj.rawMidi = message.rawMidi;
    }
    return obj;
  },

  create(base?: DeepPartial<MidiKbdConnection>): MidiKbdConnection {
    return MidiKbdConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiKbdConnection>): MidiKbdConnection {
    const message = createBaseMidiKbdConnection();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.rawMidi = object.rawMidi ?? false;
    return message;
  },
};

function createBaseMidiKbdConnectionList(): MidiKbdConnectionList {
  return { connections: [] };
}

export const MidiKbdConnectionList: MessageFns<MidiKbdConnectionList> = {
  encode(message: MidiKbdConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      MidiKbdConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiKbdConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiKbdConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(MidiKbdConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiKbdConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiKbdConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiKbdConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiKbdConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MidiKbdConnectionList>): MidiKbdConnectionList {
    return MidiKbdConnectionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiKbdConnectionList>): MidiKbdConnectionList {
    const message = createBaseMidiKbdConnectionList();
    message.connections = object.connections?.map((e) => MidiKbdConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiCCConnection(): MidiCCConnection {
  return {
    parameter: undefined,
    channel: undefined,
    port: 0,
    ccNumber: 0,
    minRange: 0,
    maxRange: 0,
    relativeMode: false,
  };
}

export const MidiCCConnection: MessageFns<MidiCCConnection> = {
  encode(message: MidiCCConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.ccNumber !== 0) {
      writer.uint32(32).int32(message.ccNumber);
    }
    if (message.minRange !== 0) {
      writer.uint32(45).float(message.minRange);
    }
    if (message.maxRange !== 0) {
      writer.uint32(53).float(message.maxRange);
    }
    if (message.relativeMode !== false) {
      writer.uint32(56).bool(message.relativeMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiCCConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiCCConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ccNumber = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.minRange = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.maxRange = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.relativeMode = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiCCConnection {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      ccNumber: isSet(object.ccNumber) ? globalThis.Number(object.ccNumber) : 0,
      minRange: isSet(object.minRange) ? globalThis.Number(object.minRange) : 0,
      maxRange: isSet(object.maxRange) ? globalThis.Number(object.maxRange) : 0,
      relativeMode: isSet(object.relativeMode) ? globalThis.Boolean(object.relativeMode) : false,
    };
  },

  toJSON(message: MidiCCConnection): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.ccNumber !== 0) {
      obj.ccNumber = Math.round(message.ccNumber);
    }
    if (message.minRange !== 0) {
      obj.minRange = message.minRange;
    }
    if (message.maxRange !== 0) {
      obj.maxRange = message.maxRange;
    }
    if (message.relativeMode !== false) {
      obj.relativeMode = message.relativeMode;
    }
    return obj;
  },

  create(base?: DeepPartial<MidiCCConnection>): MidiCCConnection {
    return MidiCCConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiCCConnection>): MidiCCConnection {
    const message = createBaseMidiCCConnection();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.ccNumber = object.ccNumber ?? 0;
    message.minRange = object.minRange ?? 0;
    message.maxRange = object.maxRange ?? 0;
    message.relativeMode = object.relativeMode ?? false;
    return message;
  },
};

function createBaseMidiCCConnectionList(): MidiCCConnectionList {
  return { connections: [] };
}

export const MidiCCConnectionList: MessageFns<MidiCCConnectionList> = {
  encode(message: MidiCCConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      MidiCCConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiCCConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiCCConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(MidiCCConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiCCConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiCCConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiCCConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiCCConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MidiCCConnectionList>): MidiCCConnectionList {
    return MidiCCConnectionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiCCConnectionList>): MidiCCConnectionList {
    const message = createBaseMidiCCConnectionList();
    message.connections = object.connections?.map((e) => MidiCCConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiCCConnectionListResponse(): MidiCCConnectionListResponse {
  return { status: undefined, connections: [] };
}

export const MidiCCConnectionListResponse: MessageFns<MidiCCConnectionListResponse> = {
  encode(message: MidiCCConnectionListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.connections) {
      MidiCCConnection.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiCCConnectionListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiCCConnectionListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connections.push(MidiCCConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiCCConnectionListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiCCConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiCCConnectionListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiCCConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MidiCCConnectionListResponse>): MidiCCConnectionListResponse {
    return MidiCCConnectionListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiCCConnectionListResponse>): MidiCCConnectionListResponse {
    const message = createBaseMidiCCConnectionListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.connections = object.connections?.map((e) => MidiCCConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiPCConnection(): MidiPCConnection {
  return { processor: undefined, channel: undefined, port: 0 };
}

export const MidiPCConnection: MessageFns<MidiPCConnection> = {
  encode(message: MidiPCConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiPCConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiPCConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiPCConnection {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: MidiPCConnection): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<MidiPCConnection>): MidiPCConnection {
    return MidiPCConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiPCConnection>): MidiPCConnection {
    const message = createBaseMidiPCConnection();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseMidiPCConnectionList(): MidiPCConnectionList {
  return { connections: [] };
}

export const MidiPCConnectionList: MessageFns<MidiPCConnectionList> = {
  encode(message: MidiPCConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      MidiPCConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiPCConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiPCConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(MidiPCConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiPCConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiPCConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiPCConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiPCConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MidiPCConnectionList>): MidiPCConnectionList {
    return MidiPCConnectionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiPCConnectionList>): MidiPCConnectionList {
    const message = createBaseMidiPCConnectionList();
    message.connections = object.connections?.map((e) => MidiPCConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiPCConnectionListResponse(): MidiPCConnectionListResponse {
  return { status: undefined, connections: [] };
}

export const MidiPCConnectionListResponse: MessageFns<MidiPCConnectionListResponse> = {
  encode(message: MidiPCConnectionListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      CommandStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.connections) {
      MidiPCConnection.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiPCConnectionListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiPCConnectionListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = CommandStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connections.push(MidiPCConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiPCConnectionListResponse {
    return {
      status: isSet(object.status) ? CommandStatus.fromJSON(object.status) : undefined,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiPCConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiPCConnectionListResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = CommandStatus.toJSON(message.status);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiPCConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MidiPCConnectionListResponse>): MidiPCConnectionListResponse {
    return MidiPCConnectionListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiPCConnectionListResponse>): MidiPCConnectionListResponse {
    const message = createBaseMidiPCConnectionListResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? CommandStatus.fromPartial(object.status)
      : undefined;
    message.connections = object.connections?.map((e) => MidiPCConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiClockSetRequest(): MidiClockSetRequest {
  return { port: 0, enabled: false };
}

export const MidiClockSetRequest: MessageFns<MidiClockSetRequest> = {
  encode(message: MidiClockSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== 0) {
      writer.uint32(8).int32(message.port);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiClockSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiClockSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiClockSetRequest {
    return {
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: MidiClockSetRequest): unknown {
    const obj: any = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<MidiClockSetRequest>): MidiClockSetRequest {
    return MidiClockSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiClockSetRequest>): MidiClockSetRequest {
    const message = createBaseMidiClockSetRequest();
    message.port = object.port ?? 0;
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseOscParameterOutputList(): OscParameterOutputList {
  return { path: [] };
}

export const OscParameterOutputList: MessageFns<OscParameterOutputList> = {
  encode(message: OscParameterOutputList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.path) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OscParameterOutputList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOscParameterOutputList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OscParameterOutputList {
    return { path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: OscParameterOutputList): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<OscParameterOutputList>): OscParameterOutputList {
    return OscParameterOutputList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OscParameterOutputList>): OscParameterOutputList {
    const message = createBaseOscParameterOutputList();
    message.path = object.path?.map((e) => e) || [];
    return message;
  },
};

function createBaseTransportUpdate(): TransportUpdate {
  return { tempo: undefined, playingMode: undefined, syncMode: undefined, timeSignature: undefined };
}

export const TransportUpdate: MessageFns<TransportUpdate> = {
  encode(message: TransportUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tempo !== undefined) {
      writer.uint32(13).float(message.tempo);
    }
    if (message.playingMode !== undefined) {
      PlayingMode.encode(message.playingMode, writer.uint32(18).fork()).join();
    }
    if (message.syncMode !== undefined) {
      SyncMode.encode(message.syncMode, writer.uint32(26).fork()).join();
    }
    if (message.timeSignature !== undefined) {
      TimeSignature.encode(message.timeSignature, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransportUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransportUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.tempo = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playingMode = PlayingMode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.syncMode = SyncMode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeSignature = TimeSignature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransportUpdate {
    return {
      tempo: isSet(object.tempo) ? globalThis.Number(object.tempo) : undefined,
      playingMode: isSet(object.playingMode) ? PlayingMode.fromJSON(object.playingMode) : undefined,
      syncMode: isSet(object.syncMode) ? SyncMode.fromJSON(object.syncMode) : undefined,
      timeSignature: isSet(object.timeSignature) ? TimeSignature.fromJSON(object.timeSignature) : undefined,
    };
  },

  toJSON(message: TransportUpdate): unknown {
    const obj: any = {};
    if (message.tempo !== undefined) {
      obj.tempo = message.tempo;
    }
    if (message.playingMode !== undefined) {
      obj.playingMode = PlayingMode.toJSON(message.playingMode);
    }
    if (message.syncMode !== undefined) {
      obj.syncMode = SyncMode.toJSON(message.syncMode);
    }
    if (message.timeSignature !== undefined) {
      obj.timeSignature = TimeSignature.toJSON(message.timeSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<TransportUpdate>): TransportUpdate {
    return TransportUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransportUpdate>): TransportUpdate {
    const message = createBaseTransportUpdate();
    message.tempo = object.tempo ?? undefined;
    message.playingMode = (object.playingMode !== undefined && object.playingMode !== null)
      ? PlayingMode.fromPartial(object.playingMode)
      : undefined;
    message.syncMode = (object.syncMode !== undefined && object.syncMode !== null)
      ? SyncMode.fromPartial(object.syncMode)
      : undefined;
    message.timeSignature = (object.timeSignature !== undefined && object.timeSignature !== null)
      ? TimeSignature.fromPartial(object.timeSignature)
      : undefined;
    return message;
  },
};

function createBaseTrackUpdate(): TrackUpdate {
  return { action: 0, track: undefined };
}

export const TrackUpdate: MessageFns<TrackUpdate> = {
  encode(message: TrackUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackUpdate {
    return {
      action: isSet(object.action) ? trackUpdate_ActionFromJSON(object.action) : 0,
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
    };
  },

  toJSON(message: TrackUpdate): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = trackUpdate_ActionToJSON(message.action);
    }
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    return obj;
  },

  create(base?: DeepPartial<TrackUpdate>): TrackUpdate {
    return TrackUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackUpdate>): TrackUpdate {
    const message = createBaseTrackUpdate();
    message.action = object.action ?? 0;
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    return message;
  },
};

function createBaseProcessorUpdate(): ProcessorUpdate {
  return { action: 0, processor: undefined, parentTrack: undefined };
}

export const ProcessorUpdate: MessageFns<ProcessorUpdate> = {
  encode(message: ProcessorUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(18).fork()).join();
    }
    if (message.parentTrack !== undefined) {
      TrackIdentifier.encode(message.parentTrack, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentTrack = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorUpdate {
    return {
      action: isSet(object.action) ? processorUpdate_ActionFromJSON(object.action) : 0,
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      parentTrack: isSet(object.parentTrack) ? TrackIdentifier.fromJSON(object.parentTrack) : undefined,
    };
  },

  toJSON(message: ProcessorUpdate): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = processorUpdate_ActionToJSON(message.action);
    }
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.parentTrack !== undefined) {
      obj.parentTrack = TrackIdentifier.toJSON(message.parentTrack);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessorUpdate>): ProcessorUpdate {
    return ProcessorUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessorUpdate>): ProcessorUpdate {
    const message = createBaseProcessorUpdate();
    message.action = object.action ?? 0;
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.parentTrack = (object.parentTrack !== undefined && object.parentTrack !== null)
      ? TrackIdentifier.fromPartial(object.parentTrack)
      : undefined;
    return message;
  },
};

function createBaseMidiKbdConnectionState(): MidiKbdConnectionState {
  return { track: "", channel: undefined, port: 0, rawMidi: false };
}

export const MidiKbdConnectionState: MessageFns<MidiKbdConnectionState> = {
  encode(message: MidiKbdConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== "") {
      writer.uint32(10).string(message.track);
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.rawMidi !== false) {
      writer.uint32(56).bool(message.rawMidi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiKbdConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiKbdConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rawMidi = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiKbdConnectionState {
    return {
      track: isSet(object.track) ? globalThis.String(object.track) : "",
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      rawMidi: isSet(object.rawMidi) ? globalThis.Boolean(object.rawMidi) : false,
    };
  },

  toJSON(message: MidiKbdConnectionState): unknown {
    const obj: any = {};
    if (message.track !== "") {
      obj.track = message.track;
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.rawMidi !== false) {
      obj.rawMidi = message.rawMidi;
    }
    return obj;
  },

  create(base?: DeepPartial<MidiKbdConnectionState>): MidiKbdConnectionState {
    return MidiKbdConnectionState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiKbdConnectionState>): MidiKbdConnectionState {
    const message = createBaseMidiKbdConnectionState();
    message.track = object.track ?? "";
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.rawMidi = object.rawMidi ?? false;
    return message;
  },
};

function createBaseMidiCCConnectionState(): MidiCCConnectionState {
  return {
    processor: "",
    parameter: undefined,
    channel: undefined,
    port: 0,
    ccNumber: 0,
    minRange: 0,
    maxRange: 0,
    relativeMode: false,
  };
}

export const MidiCCConnectionState: MessageFns<MidiCCConnectionState> = {
  encode(message: MidiCCConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== "") {
      writer.uint32(10).string(message.processor);
    }
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(18).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(26).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(32).int32(message.port);
    }
    if (message.ccNumber !== 0) {
      writer.uint32(40).int32(message.ccNumber);
    }
    if (message.minRange !== 0) {
      writer.uint32(53).float(message.minRange);
    }
    if (message.maxRange !== 0) {
      writer.uint32(61).float(message.maxRange);
    }
    if (message.relativeMode !== false) {
      writer.uint32(64).bool(message.relativeMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiCCConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiCCConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ccNumber = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.minRange = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.maxRange = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.relativeMode = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiCCConnectionState {
    return {
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      ccNumber: isSet(object.ccNumber) ? globalThis.Number(object.ccNumber) : 0,
      minRange: isSet(object.minRange) ? globalThis.Number(object.minRange) : 0,
      maxRange: isSet(object.maxRange) ? globalThis.Number(object.maxRange) : 0,
      relativeMode: isSet(object.relativeMode) ? globalThis.Boolean(object.relativeMode) : false,
    };
  },

  toJSON(message: MidiCCConnectionState): unknown {
    const obj: any = {};
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.ccNumber !== 0) {
      obj.ccNumber = Math.round(message.ccNumber);
    }
    if (message.minRange !== 0) {
      obj.minRange = message.minRange;
    }
    if (message.maxRange !== 0) {
      obj.maxRange = message.maxRange;
    }
    if (message.relativeMode !== false) {
      obj.relativeMode = message.relativeMode;
    }
    return obj;
  },

  create(base?: DeepPartial<MidiCCConnectionState>): MidiCCConnectionState {
    return MidiCCConnectionState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiCCConnectionState>): MidiCCConnectionState {
    const message = createBaseMidiCCConnectionState();
    message.processor = object.processor ?? "";
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.ccNumber = object.ccNumber ?? 0;
    message.minRange = object.minRange ?? 0;
    message.maxRange = object.maxRange ?? 0;
    message.relativeMode = object.relativeMode ?? false;
    return message;
  },
};

function createBaseMidiPCConnectionState(): MidiPCConnectionState {
  return { processor: "", channel: undefined, port: 0 };
}

export const MidiPCConnectionState: MessageFns<MidiPCConnectionState> = {
  encode(message: MidiPCConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== "") {
      writer.uint32(10).string(message.processor);
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiPCConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiPCConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiPCConnectionState {
    return {
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: MidiPCConnectionState): unknown {
    const obj: any = {};
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<MidiPCConnectionState>): MidiPCConnectionState {
    return MidiPCConnectionState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiPCConnectionState>): MidiPCConnectionState {
    const message = createBaseMidiPCConnectionState();
    message.processor = object.processor ?? "";
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseMidiState(): MidiState {
  return {
    inputs: 0,
    outputs: 0,
    kbdInputConnections: [],
    kbdOutputConnections: [],
    ccConnections: [],
    pcConnections: [],
    enabledClockOutputs: [],
  };
}

export const MidiState: MessageFns<MidiState> = {
  encode(message: MidiState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputs !== 0) {
      writer.uint32(8).int32(message.inputs);
    }
    if (message.outputs !== 0) {
      writer.uint32(16).int32(message.outputs);
    }
    for (const v of message.kbdInputConnections) {
      MidiKbdConnectionState.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.kbdOutputConnections) {
      MidiKbdConnectionState.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.ccConnections) {
      MidiCCConnectionState.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.pcConnections) {
      MidiPCConnectionState.encode(v!, writer.uint32(50).fork()).join();
    }
    writer.uint32(58).fork();
    for (const v of message.enabledClockOutputs) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputs = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputs = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kbdInputConnections.push(MidiKbdConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kbdOutputConnections.push(MidiKbdConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ccConnections.push(MidiCCConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pcConnections.push(MidiPCConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.enabledClockOutputs.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enabledClockOutputs.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiState {
    return {
      inputs: isSet(object.inputs) ? globalThis.Number(object.inputs) : 0,
      outputs: isSet(object.outputs) ? globalThis.Number(object.outputs) : 0,
      kbdInputConnections: globalThis.Array.isArray(object?.kbdInputConnections)
        ? object.kbdInputConnections.map((e: any) => MidiKbdConnectionState.fromJSON(e))
        : [],
      kbdOutputConnections: globalThis.Array.isArray(object?.kbdOutputConnections)
        ? object.kbdOutputConnections.map((e: any) => MidiKbdConnectionState.fromJSON(e))
        : [],
      ccConnections: globalThis.Array.isArray(object?.ccConnections)
        ? object.ccConnections.map((e: any) => MidiCCConnectionState.fromJSON(e))
        : [],
      pcConnections: globalThis.Array.isArray(object?.pcConnections)
        ? object.pcConnections.map((e: any) => MidiPCConnectionState.fromJSON(e))
        : [],
      enabledClockOutputs: globalThis.Array.isArray(object?.enabledClockOutputs)
        ? object.enabledClockOutputs.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: MidiState): unknown {
    const obj: any = {};
    if (message.inputs !== 0) {
      obj.inputs = Math.round(message.inputs);
    }
    if (message.outputs !== 0) {
      obj.outputs = Math.round(message.outputs);
    }
    if (message.kbdInputConnections?.length) {
      obj.kbdInputConnections = message.kbdInputConnections.map((e) => MidiKbdConnectionState.toJSON(e));
    }
    if (message.kbdOutputConnections?.length) {
      obj.kbdOutputConnections = message.kbdOutputConnections.map((e) => MidiKbdConnectionState.toJSON(e));
    }
    if (message.ccConnections?.length) {
      obj.ccConnections = message.ccConnections.map((e) => MidiCCConnectionState.toJSON(e));
    }
    if (message.pcConnections?.length) {
      obj.pcConnections = message.pcConnections.map((e) => MidiPCConnectionState.toJSON(e));
    }
    if (message.enabledClockOutputs?.length) {
      obj.enabledClockOutputs = message.enabledClockOutputs.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MidiState>): MidiState {
    return MidiState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MidiState>): MidiState {
    const message = createBaseMidiState();
    message.inputs = object.inputs ?? 0;
    message.outputs = object.outputs ?? 0;
    message.kbdInputConnections = object.kbdInputConnections?.map((e) => MidiKbdConnectionState.fromPartial(e)) || [];
    message.kbdOutputConnections = object.kbdOutputConnections?.map((e) => MidiKbdConnectionState.fromPartial(e)) || [];
    message.ccConnections = object.ccConnections?.map((e) => MidiCCConnectionState.fromPartial(e)) || [];
    message.pcConnections = object.pcConnections?.map((e) => MidiPCConnectionState.fromPartial(e)) || [];
    message.enabledClockOutputs = object.enabledClockOutputs?.map((e) => e) || [];
    return message;
  },
};

function createBaseOscParameterState(): OscParameterState {
  return { processor: "", parameterIds: [] };
}

export const OscParameterState: MessageFns<OscParameterState> = {
  encode(message: OscParameterState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== "") {
      writer.uint32(10).string(message.processor);
    }
    writer.uint32(18).fork();
    for (const v of message.parameterIds) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OscParameterState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOscParameterState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.parameterIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.parameterIds.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OscParameterState {
    return {
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      parameterIds: globalThis.Array.isArray(object?.parameterIds)
        ? object.parameterIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: OscParameterState): unknown {
    const obj: any = {};
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.parameterIds?.length) {
      obj.parameterIds = message.parameterIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OscParameterState>): OscParameterState {
    return OscParameterState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OscParameterState>): OscParameterState {
    const message = createBaseOscParameterState();
    message.processor = object.processor ?? "";
    message.parameterIds = object.parameterIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOscState(): OscState {
  return { enableAllProcessorOutputs: false, enabledProcessorOutputs: [] };
}

export const OscState: MessageFns<OscState> = {
  encode(message: OscState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableAllProcessorOutputs !== false) {
      writer.uint32(8).bool(message.enableAllProcessorOutputs);
    }
    for (const v of message.enabledProcessorOutputs) {
      OscParameterState.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OscState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOscState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enableAllProcessorOutputs = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enabledProcessorOutputs.push(OscParameterState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OscState {
    return {
      enableAllProcessorOutputs: isSet(object.enableAllProcessorOutputs)
        ? globalThis.Boolean(object.enableAllProcessorOutputs)
        : false,
      enabledProcessorOutputs: globalThis.Array.isArray(object?.enabledProcessorOutputs)
        ? object.enabledProcessorOutputs.map((e: any) => OscParameterState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OscState): unknown {
    const obj: any = {};
    if (message.enableAllProcessorOutputs !== false) {
      obj.enableAllProcessorOutputs = message.enableAllProcessorOutputs;
    }
    if (message.enabledProcessorOutputs?.length) {
      obj.enabledProcessorOutputs = message.enabledProcessorOutputs.map((e) => OscParameterState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OscState>): OscState {
    return OscState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OscState>): OscState {
    const message = createBaseOscState();
    message.enableAllProcessorOutputs = object.enableAllProcessorOutputs ?? false;
    message.enabledProcessorOutputs = object.enabledProcessorOutputs?.map((e) => OscParameterState.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseTrackAudioConnectionState(): TrackAudioConnectionState {
  return { track: "", trackChannel: 0, engineChannel: 0 };
}

export const TrackAudioConnectionState: MessageFns<TrackAudioConnectionState> = {
  encode(message: TrackAudioConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== "") {
      writer.uint32(10).string(message.track);
    }
    if (message.trackChannel !== 0) {
      writer.uint32(16).int32(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      writer.uint32(24).int32(message.engineChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackAudioConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackAudioConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trackChannel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.engineChannel = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackAudioConnectionState {
    return {
      track: isSet(object.track) ? globalThis.String(object.track) : "",
      trackChannel: isSet(object.trackChannel) ? globalThis.Number(object.trackChannel) : 0,
      engineChannel: isSet(object.engineChannel) ? globalThis.Number(object.engineChannel) : 0,
    };
  },

  toJSON(message: TrackAudioConnectionState): unknown {
    const obj: any = {};
    if (message.track !== "") {
      obj.track = message.track;
    }
    if (message.trackChannel !== 0) {
      obj.trackChannel = Math.round(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      obj.engineChannel = Math.round(message.engineChannel);
    }
    return obj;
  },

  create(base?: DeepPartial<TrackAudioConnectionState>): TrackAudioConnectionState {
    return TrackAudioConnectionState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackAudioConnectionState>): TrackAudioConnectionState {
    const message = createBaseTrackAudioConnectionState();
    message.track = object.track ?? "";
    message.trackChannel = object.trackChannel ?? 0;
    message.engineChannel = object.engineChannel ?? 0;
    return message;
  },
};

function createBaseEngineState(): EngineState {
  return {
    sampleRate: 0,
    tempo: 0,
    playingMode: undefined,
    syncMode: undefined,
    timeSignature: undefined,
    clipDetectionInput: false,
    clipDetectionOutput: false,
    masterLimiter: false,
    usedAudioInputs: 0,
    usedAudioOutputs: 0,
    inputConnections: [],
    outputConnections: [],
  };
}

export const EngineState: MessageFns<EngineState> = {
  encode(message: EngineState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleRate !== 0) {
      writer.uint32(13).float(message.sampleRate);
    }
    if (message.tempo !== 0) {
      writer.uint32(21).float(message.tempo);
    }
    if (message.playingMode !== undefined) {
      PlayingMode.encode(message.playingMode, writer.uint32(26).fork()).join();
    }
    if (message.syncMode !== undefined) {
      SyncMode.encode(message.syncMode, writer.uint32(34).fork()).join();
    }
    if (message.timeSignature !== undefined) {
      TimeSignature.encode(message.timeSignature, writer.uint32(42).fork()).join();
    }
    if (message.clipDetectionInput !== false) {
      writer.uint32(48).bool(message.clipDetectionInput);
    }
    if (message.clipDetectionOutput !== false) {
      writer.uint32(56).bool(message.clipDetectionOutput);
    }
    if (message.masterLimiter !== false) {
      writer.uint32(64).bool(message.masterLimiter);
    }
    if (message.usedAudioInputs !== 0) {
      writer.uint32(72).int32(message.usedAudioInputs);
    }
    if (message.usedAudioOutputs !== 0) {
      writer.uint32(80).int32(message.usedAudioOutputs);
    }
    for (const v of message.inputConnections) {
      TrackAudioConnectionState.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.outputConnections) {
      TrackAudioConnectionState.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.sampleRate = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.tempo = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playingMode = PlayingMode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.syncMode = SyncMode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timeSignature = TimeSignature.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.clipDetectionInput = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.clipDetectionOutput = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.masterLimiter = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.usedAudioInputs = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.usedAudioOutputs = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.inputConnections.push(TrackAudioConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.outputConnections.push(TrackAudioConnectionState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineState {
    return {
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
      tempo: isSet(object.tempo) ? globalThis.Number(object.tempo) : 0,
      playingMode: isSet(object.playingMode) ? PlayingMode.fromJSON(object.playingMode) : undefined,
      syncMode: isSet(object.syncMode) ? SyncMode.fromJSON(object.syncMode) : undefined,
      timeSignature: isSet(object.timeSignature) ? TimeSignature.fromJSON(object.timeSignature) : undefined,
      clipDetectionInput: isSet(object.clipDetectionInput) ? globalThis.Boolean(object.clipDetectionInput) : false,
      clipDetectionOutput: isSet(object.clipDetectionOutput) ? globalThis.Boolean(object.clipDetectionOutput) : false,
      masterLimiter: isSet(object.masterLimiter) ? globalThis.Boolean(object.masterLimiter) : false,
      usedAudioInputs: isSet(object.usedAudioInputs) ? globalThis.Number(object.usedAudioInputs) : 0,
      usedAudioOutputs: isSet(object.usedAudioOutputs) ? globalThis.Number(object.usedAudioOutputs) : 0,
      inputConnections: globalThis.Array.isArray(object?.inputConnections)
        ? object.inputConnections.map((e: any) => TrackAudioConnectionState.fromJSON(e))
        : [],
      outputConnections: globalThis.Array.isArray(object?.outputConnections)
        ? object.outputConnections.map((e: any) => TrackAudioConnectionState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EngineState): unknown {
    const obj: any = {};
    if (message.sampleRate !== 0) {
      obj.sampleRate = message.sampleRate;
    }
    if (message.tempo !== 0) {
      obj.tempo = message.tempo;
    }
    if (message.playingMode !== undefined) {
      obj.playingMode = PlayingMode.toJSON(message.playingMode);
    }
    if (message.syncMode !== undefined) {
      obj.syncMode = SyncMode.toJSON(message.syncMode);
    }
    if (message.timeSignature !== undefined) {
      obj.timeSignature = TimeSignature.toJSON(message.timeSignature);
    }
    if (message.clipDetectionInput !== false) {
      obj.clipDetectionInput = message.clipDetectionInput;
    }
    if (message.clipDetectionOutput !== false) {
      obj.clipDetectionOutput = message.clipDetectionOutput;
    }
    if (message.masterLimiter !== false) {
      obj.masterLimiter = message.masterLimiter;
    }
    if (message.usedAudioInputs !== 0) {
      obj.usedAudioInputs = Math.round(message.usedAudioInputs);
    }
    if (message.usedAudioOutputs !== 0) {
      obj.usedAudioOutputs = Math.round(message.usedAudioOutputs);
    }
    if (message.inputConnections?.length) {
      obj.inputConnections = message.inputConnections.map((e) => TrackAudioConnectionState.toJSON(e));
    }
    if (message.outputConnections?.length) {
      obj.outputConnections = message.outputConnections.map((e) => TrackAudioConnectionState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EngineState>): EngineState {
    return EngineState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineState>): EngineState {
    const message = createBaseEngineState();
    message.sampleRate = object.sampleRate ?? 0;
    message.tempo = object.tempo ?? 0;
    message.playingMode = (object.playingMode !== undefined && object.playingMode !== null)
      ? PlayingMode.fromPartial(object.playingMode)
      : undefined;
    message.syncMode = (object.syncMode !== undefined && object.syncMode !== null)
      ? SyncMode.fromPartial(object.syncMode)
      : undefined;
    message.timeSignature = (object.timeSignature !== undefined && object.timeSignature !== null)
      ? TimeSignature.fromPartial(object.timeSignature)
      : undefined;
    message.clipDetectionInput = object.clipDetectionInput ?? false;
    message.clipDetectionOutput = object.clipDetectionOutput ?? false;
    message.masterLimiter = object.masterLimiter ?? false;
    message.usedAudioInputs = object.usedAudioInputs ?? 0;
    message.usedAudioOutputs = object.usedAudioOutputs ?? 0;
    message.inputConnections = object.inputConnections?.map((e) => TrackAudioConnectionState.fromPartial(e)) || [];
    message.outputConnections = object.outputConnections?.map((e) => TrackAudioConnectionState.fromPartial(e)) || [];
    return message;
  },
};

function createBasePluginClass(): PluginClass {
  return { name: "", label: "", uid: "", path: "", type: undefined, state: undefined };
}

export const PluginClass: MessageFns<PluginClass> = {
  encode(message: PluginClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.type !== undefined) {
      PluginType.encode(message.type, writer.uint32(42).fork()).join();
    }
    if (message.state !== undefined) {
      ProcessorState.encode(message.state, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = PluginType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.state = ProcessorState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginClass {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      type: isSet(object.type) ? PluginType.fromJSON(object.type) : undefined,
      state: isSet(object.state) ? ProcessorState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: PluginClass): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.type !== undefined) {
      obj.type = PluginType.toJSON(message.type);
    }
    if (message.state !== undefined) {
      obj.state = ProcessorState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<PluginClass>): PluginClass {
    return PluginClass.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluginClass>): PluginClass {
    const message = createBasePluginClass();
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.uid = object.uid ?? "";
    message.path = object.path ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? PluginType.fromPartial(object.type)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ProcessorState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseTrackState(): TrackState {
  return {
    name: "",
    label: "",
    channels: 0,
    buses: 0,
    thread: 0,
    type: undefined,
    trackState: undefined,
    processors: [],
  };
}

export const TrackState: MessageFns<TrackState> = {
  encode(message: TrackState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.channels !== 0) {
      writer.uint32(24).int32(message.channels);
    }
    if (message.buses !== 0) {
      writer.uint32(32).int32(message.buses);
    }
    if (message.thread !== 0) {
      writer.uint32(40).int32(message.thread);
    }
    if (message.type !== undefined) {
      TrackType.encode(message.type, writer.uint32(50).fork()).join();
    }
    if (message.trackState !== undefined) {
      ProcessorState.encode(message.trackState, writer.uint32(58).fork()).join();
    }
    for (const v of message.processors) {
      PluginClass.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channels = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.buses = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.thread = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = TrackType.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.trackState = ProcessorState.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processors.push(PluginClass.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackState {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
      buses: isSet(object.buses) ? globalThis.Number(object.buses) : 0,
      thread: isSet(object.thread) ? globalThis.Number(object.thread) : 0,
      type: isSet(object.type) ? TrackType.fromJSON(object.type) : undefined,
      trackState: isSet(object.trackState) ? ProcessorState.fromJSON(object.trackState) : undefined,
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => PluginClass.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrackState): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    if (message.buses !== 0) {
      obj.buses = Math.round(message.buses);
    }
    if (message.thread !== 0) {
      obj.thread = Math.round(message.thread);
    }
    if (message.type !== undefined) {
      obj.type = TrackType.toJSON(message.type);
    }
    if (message.trackState !== undefined) {
      obj.trackState = ProcessorState.toJSON(message.trackState);
    }
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => PluginClass.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TrackState>): TrackState {
    return TrackState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackState>): TrackState {
    const message = createBaseTrackState();
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.channels = object.channels ?? 0;
    message.buses = object.buses ?? 0;
    message.thread = object.thread ?? 0;
    message.type = (object.type !== undefined && object.type !== null) ? TrackType.fromPartial(object.type) : undefined;
    message.trackState = (object.trackState !== undefined && object.trackState !== null)
      ? ProcessorState.fromPartial(object.trackState)
      : undefined;
    message.processors = object.processors?.map((e) => PluginClass.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionState(): SessionState {
  return {
    sushiInfo: undefined,
    saveDate: "",
    oscState: undefined,
    midiState: undefined,
    engineState: undefined,
    tracks: [],
  };
}

export const SessionState: MessageFns<SessionState> = {
  encode(message: SessionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sushiInfo !== undefined) {
      SushiBuildInfo.encode(message.sushiInfo, writer.uint32(10).fork()).join();
    }
    if (message.saveDate !== "") {
      writer.uint32(18).string(message.saveDate);
    }
    if (message.oscState !== undefined) {
      OscState.encode(message.oscState, writer.uint32(26).fork()).join();
    }
    if (message.midiState !== undefined) {
      MidiState.encode(message.midiState, writer.uint32(34).fork()).join();
    }
    if (message.engineState !== undefined) {
      EngineState.encode(message.engineState, writer.uint32(42).fork()).join();
    }
    for (const v of message.tracks) {
      TrackState.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sushiInfo = SushiBuildInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.saveDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oscState = OscState.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.midiState = MidiState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.engineState = EngineState.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tracks.push(TrackState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionState {
    return {
      sushiInfo: isSet(object.sushiInfo) ? SushiBuildInfo.fromJSON(object.sushiInfo) : undefined,
      saveDate: isSet(object.saveDate) ? globalThis.String(object.saveDate) : "",
      oscState: isSet(object.oscState) ? OscState.fromJSON(object.oscState) : undefined,
      midiState: isSet(object.midiState) ? MidiState.fromJSON(object.midiState) : undefined,
      engineState: isSet(object.engineState) ? EngineState.fromJSON(object.engineState) : undefined,
      tracks: globalThis.Array.isArray(object?.tracks) ? object.tracks.map((e: any) => TrackState.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionState): unknown {
    const obj: any = {};
    if (message.sushiInfo !== undefined) {
      obj.sushiInfo = SushiBuildInfo.toJSON(message.sushiInfo);
    }
    if (message.saveDate !== "") {
      obj.saveDate = message.saveDate;
    }
    if (message.oscState !== undefined) {
      obj.oscState = OscState.toJSON(message.oscState);
    }
    if (message.midiState !== undefined) {
      obj.midiState = MidiState.toJSON(message.midiState);
    }
    if (message.engineState !== undefined) {
      obj.engineState = EngineState.toJSON(message.engineState);
    }
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => TrackState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SessionState>): SessionState {
    return SessionState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionState>): SessionState {
    const message = createBaseSessionState();
    message.sushiInfo = (object.sushiInfo !== undefined && object.sushiInfo !== null)
      ? SushiBuildInfo.fromPartial(object.sushiInfo)
      : undefined;
    message.saveDate = object.saveDate ?? "";
    message.oscState = (object.oscState !== undefined && object.oscState !== null)
      ? OscState.fromPartial(object.oscState)
      : undefined;
    message.midiState = (object.midiState !== undefined && object.midiState !== null)
      ? MidiState.fromPartial(object.midiState)
      : undefined;
    message.engineState = (object.engineState !== undefined && object.engineState !== null)
      ? EngineState.fromPartial(object.engineState)
      : undefined;
    message.tracks = object.tracks?.map((e) => TrackState.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
