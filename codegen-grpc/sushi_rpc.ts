// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.3
// source: sushi_rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";

export const protobufPackage = "sushi_rpc";

export interface GenericVoidValue {
}

export interface GenericFloatValue {
  value: number;
}

export interface GenericIntValue {
  value: number;
}

export interface GenericBoolValue {
  value: boolean;
}

export interface GenericStringValue {
  value: string;
}

export interface OptionalBoolValue {
  hasValue: boolean;
  value: boolean;
}

export interface OptionalIntValue {
  hasValue: boolean;
  value: number;
}

export interface SushiBuildInfo {
  version: string;
  buildOptions: string[];
  audioBufferSize: number;
  commitHash: string;
  buildDate: string;
}

export interface TrackIdentifier {
  id: number;
}

export interface ProcessorIdentifier {
  id: number;
}

export interface ParameterIdentifier {
  processorId: number;
  parameterId: number;
}

export interface PropertyIdentifier {
  processorId: number;
  propertyId: number;
}

/** 0 is reserved for "not set" in protobuf, so we don't use it for a valid response */
export interface ParameterType {
  type: ParameterType_Type;
}

export enum ParameterType_Type {
  DUMMY = 0,
  BOOL = 1,
  INT = 2,
  FLOAT = 3,
  UNRECOGNIZED = -1,
}

export function parameterType_TypeFromJSON(object: any): ParameterType_Type {
  switch (object) {
    case 0:
    case "DUMMY":
      return ParameterType_Type.DUMMY;
    case 1:
    case "BOOL":
      return ParameterType_Type.BOOL;
    case 2:
    case "INT":
      return ParameterType_Type.INT;
    case 3:
    case "FLOAT":
      return ParameterType_Type.FLOAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParameterType_Type.UNRECOGNIZED;
  }
}

export function parameterType_TypeToJSON(object: ParameterType_Type): string {
  switch (object) {
    case ParameterType_Type.DUMMY:
      return "DUMMY";
    case ParameterType_Type.BOOL:
      return "BOOL";
    case ParameterType_Type.INT:
      return "INT";
    case ParameterType_Type.FLOAT:
      return "FLOAT";
    case ParameterType_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PlayingMode {
  mode: PlayingMode_Mode;
}

export enum PlayingMode_Mode {
  DUMMY = 0,
  STOPPED = 1,
  PLAYING = 2,
  RECORDING = 3,
  UNRECOGNIZED = -1,
}

export function playingMode_ModeFromJSON(object: any): PlayingMode_Mode {
  switch (object) {
    case 0:
    case "DUMMY":
      return PlayingMode_Mode.DUMMY;
    case 1:
    case "STOPPED":
      return PlayingMode_Mode.STOPPED;
    case 2:
    case "PLAYING":
      return PlayingMode_Mode.PLAYING;
    case 3:
    case "RECORDING":
      return PlayingMode_Mode.RECORDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PlayingMode_Mode.UNRECOGNIZED;
  }
}

export function playingMode_ModeToJSON(object: PlayingMode_Mode): string {
  switch (object) {
    case PlayingMode_Mode.DUMMY:
      return "DUMMY";
    case PlayingMode_Mode.STOPPED:
      return "STOPPED";
    case PlayingMode_Mode.PLAYING:
      return "PLAYING";
    case PlayingMode_Mode.RECORDING:
      return "RECORDING";
    case PlayingMode_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SyncMode {
  mode: SyncMode_Mode;
}

export enum SyncMode_Mode {
  DUMMY = 0,
  INTERNAL = 1,
  MIDI = 2,
  LINK = 3,
  UNRECOGNIZED = -1,
}

export function syncMode_ModeFromJSON(object: any): SyncMode_Mode {
  switch (object) {
    case 0:
    case "DUMMY":
      return SyncMode_Mode.DUMMY;
    case 1:
    case "INTERNAL":
      return SyncMode_Mode.INTERNAL;
    case 2:
    case "MIDI":
      return SyncMode_Mode.MIDI;
    case 3:
    case "LINK":
      return SyncMode_Mode.LINK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SyncMode_Mode.UNRECOGNIZED;
  }
}

export function syncMode_ModeToJSON(object: SyncMode_Mode): string {
  switch (object) {
    case SyncMode_Mode.DUMMY:
      return "DUMMY";
    case SyncMode_Mode.INTERNAL:
      return "INTERNAL";
    case SyncMode_Mode.MIDI:
      return "MIDI";
    case SyncMode_Mode.LINK:
      return "LINK";
    case SyncMode_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TimeSignature {
  numerator: number;
  denominator: number;
}

export interface CpuTimings {
  average: number;
  min: number;
  max: number;
}

export interface NoteOnRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  note: number;
  velocity: number;
}

export interface NoteOffRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  note: number;
  velocity: number;
}

export interface NoteAftertouchRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  note: number;
  value: number;
}

export interface NoteModulationRequest {
  track: TrackIdentifier | undefined;
  channel: number;
  value: number;
}

export interface TrackType {
  type: TrackType_Type;
}

export enum TrackType_Type {
  DUMMY = 0,
  REGULAR = 1,
  PRE = 2,
  POST = 3,
  UNRECOGNIZED = -1,
}

export function trackType_TypeFromJSON(object: any): TrackType_Type {
  switch (object) {
    case 0:
    case "DUMMY":
      return TrackType_Type.DUMMY;
    case 1:
    case "REGULAR":
      return TrackType_Type.REGULAR;
    case 2:
    case "PRE":
      return TrackType_Type.PRE;
    case 3:
    case "POST":
      return TrackType_Type.POST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrackType_Type.UNRECOGNIZED;
  }
}

export function trackType_TypeToJSON(object: TrackType_Type): string {
  switch (object) {
    case TrackType_Type.DUMMY:
      return "DUMMY";
    case TrackType_Type.REGULAR:
      return "REGULAR";
    case TrackType_Type.PRE:
      return "PRE";
    case TrackType_Type.POST:
      return "POST";
    case TrackType_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TrackInfo {
  id: number;
  label: string;
  name: string;
  channels: number;
  buses: number;
  type: TrackType | undefined;
  processors: ProcessorIdentifier[];
}

export interface TrackInfoList {
  tracks: TrackInfo[];
}

export interface ProcessorInfo {
  id: number;
  label: string;
  name: string;
  parameterCount: number;
  programCount: number;
}

export interface ProcessorInfoList {
  processors: ProcessorInfo[];
}

export interface ProgramIdentifier {
  program: number;
}

export interface ProcessorProgramIdentifier {
  processor: ProcessorIdentifier | undefined;
  program: number;
}

export interface ProgramInfo {
  id: ProgramIdentifier | undefined;
  name: string;
}

export interface ProgramInfoList {
  programs: ProgramInfo[];
}

export interface ProcessorProgramSetRequest {
  processor: ProcessorIdentifier | undefined;
  program: ProgramIdentifier | undefined;
}

export interface ProcessorBypassStateSetRequest {
  processor: ProcessorIdentifier | undefined;
  value: boolean;
}

export interface ProcessorState {
  programId: OptionalIntValue | undefined;
  bypassed: OptionalBoolValue | undefined;
  properties: PropertyValue[];
  parameters: ParameterValue[];
  binaryData: Uint8Array;
}

export interface ProcessorStateSetRequest {
  processor: ProcessorIdentifier | undefined;
  state: ProcessorState | undefined;
}

export interface ParameterInfo {
  id: number;
  type: ParameterType | undefined;
  label: string;
  name: string;
  unit: string;
  automatable: boolean;
  minDomainValue: number;
  maxDomainValue: number;
}

export interface ParameterInfoList {
  parameters: ParameterInfo[];
}

export interface ParameterIdRequest {
  processor: ProcessorIdentifier | undefined;
  ParameterName: string;
}

export interface ParameterValue {
  parameter: ParameterIdentifier | undefined;
  value: number;
}

export interface ParameterUpdate {
  parameter: ParameterIdentifier | undefined;
  normalizedValue: number;
  domainValue: number;
  formattedValue: string;
}

export interface PropertyInfo {
  id: number;
  name: string;
  label: string;
}

export interface PropertyInfoList {
  properties: PropertyInfo[];
}

export interface PropertyValue {
  property: PropertyIdentifier | undefined;
  value: string;
}

export interface PropertyIdRequest {
  processor: ProcessorIdentifier | undefined;
  propertyName: string;
}

export interface PluginType {
  type: PluginType_Type;
}

export enum PluginType_Type {
  DUMMY = 0,
  INTERNAL = 1,
  VST2X = 2,
  VST3X = 3,
  LV2 = 4,
  UNRECOGNIZED = -1,
}

export function pluginType_TypeFromJSON(object: any): PluginType_Type {
  switch (object) {
    case 0:
    case "DUMMY":
      return PluginType_Type.DUMMY;
    case 1:
    case "INTERNAL":
      return PluginType_Type.INTERNAL;
    case 2:
    case "VST2X":
      return PluginType_Type.VST2X;
    case 3:
    case "VST3X":
      return PluginType_Type.VST3X;
    case 4:
    case "LV2":
      return PluginType_Type.LV2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PluginType_Type.UNRECOGNIZED;
  }
}

export function pluginType_TypeToJSON(object: PluginType_Type): string {
  switch (object) {
    case PluginType_Type.DUMMY:
      return "DUMMY";
    case PluginType_Type.INTERNAL:
      return "INTERNAL";
    case PluginType_Type.VST2X:
      return "VST2X";
    case PluginType_Type.VST3X:
      return "VST3X";
    case PluginType_Type.LV2:
      return "LV2";
    case PluginType_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProcessorPosition {
  addToBack: boolean;
  beforeProcessor: ProcessorIdentifier | undefined;
}

export interface CreateTrackRequest {
  name: string;
  channels: number;
}

export interface CreateMultibusTrackRequest {
  name: string;
  buses: number;
}

export interface CreatePreTrackRequest {
  name: string;
}

export interface CreatePostTrackRequest {
  name: string;
}

export interface CreateProcessorRequest {
  name: string;
  uid: string;
  path: string;
  type: PluginType | undefined;
  track: TrackIdentifier | undefined;
  position: ProcessorPosition | undefined;
}

export interface MoveProcessorRequest {
  processor: ProcessorIdentifier | undefined;
  sourceTrack: TrackIdentifier | undefined;
  destTrack: TrackIdentifier | undefined;
  position: ProcessorPosition | undefined;
}

export interface DeleteProcessorRequest {
  processor: ProcessorIdentifier | undefined;
  track: TrackIdentifier | undefined;
}

export interface ParameterNotificationBlocklist {
  parameters: ParameterIdentifier[];
}

export interface PropertyNotificationBlocklist {
  properties: PropertyIdentifier[];
}

export interface MidiChannel {
  channel: MidiChannel_Channel;
}

export enum MidiChannel_Channel {
  DUMMY = 0,
  MIDI_CH_1 = 1,
  MIDI_CH_2 = 2,
  MIDI_CH_3 = 3,
  MIDI_CH_4 = 4,
  MIDI_CH_5 = 5,
  MIDI_CH_6 = 6,
  MIDI_CH_7 = 7,
  MIDI_CH_8 = 8,
  MIDI_CH_9 = 9,
  MIDI_CH_10 = 10,
  MIDI_CH_11 = 11,
  MIDI_CH_12 = 12,
  MIDI_CH_13 = 13,
  MIDI_CH_14 = 14,
  MIDI_CH_15 = 15,
  MIDI_CH_16 = 16,
  MIDI_CH_OMNI = 17,
  UNRECOGNIZED = -1,
}

export function midiChannel_ChannelFromJSON(object: any): MidiChannel_Channel {
  switch (object) {
    case 0:
    case "DUMMY":
      return MidiChannel_Channel.DUMMY;
    case 1:
    case "MIDI_CH_1":
      return MidiChannel_Channel.MIDI_CH_1;
    case 2:
    case "MIDI_CH_2":
      return MidiChannel_Channel.MIDI_CH_2;
    case 3:
    case "MIDI_CH_3":
      return MidiChannel_Channel.MIDI_CH_3;
    case 4:
    case "MIDI_CH_4":
      return MidiChannel_Channel.MIDI_CH_4;
    case 5:
    case "MIDI_CH_5":
      return MidiChannel_Channel.MIDI_CH_5;
    case 6:
    case "MIDI_CH_6":
      return MidiChannel_Channel.MIDI_CH_6;
    case 7:
    case "MIDI_CH_7":
      return MidiChannel_Channel.MIDI_CH_7;
    case 8:
    case "MIDI_CH_8":
      return MidiChannel_Channel.MIDI_CH_8;
    case 9:
    case "MIDI_CH_9":
      return MidiChannel_Channel.MIDI_CH_9;
    case 10:
    case "MIDI_CH_10":
      return MidiChannel_Channel.MIDI_CH_10;
    case 11:
    case "MIDI_CH_11":
      return MidiChannel_Channel.MIDI_CH_11;
    case 12:
    case "MIDI_CH_12":
      return MidiChannel_Channel.MIDI_CH_12;
    case 13:
    case "MIDI_CH_13":
      return MidiChannel_Channel.MIDI_CH_13;
    case 14:
    case "MIDI_CH_14":
      return MidiChannel_Channel.MIDI_CH_14;
    case 15:
    case "MIDI_CH_15":
      return MidiChannel_Channel.MIDI_CH_15;
    case 16:
    case "MIDI_CH_16":
      return MidiChannel_Channel.MIDI_CH_16;
    case 17:
    case "MIDI_CH_OMNI":
      return MidiChannel_Channel.MIDI_CH_OMNI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MidiChannel_Channel.UNRECOGNIZED;
  }
}

export function midiChannel_ChannelToJSON(object: MidiChannel_Channel): string {
  switch (object) {
    case MidiChannel_Channel.DUMMY:
      return "DUMMY";
    case MidiChannel_Channel.MIDI_CH_1:
      return "MIDI_CH_1";
    case MidiChannel_Channel.MIDI_CH_2:
      return "MIDI_CH_2";
    case MidiChannel_Channel.MIDI_CH_3:
      return "MIDI_CH_3";
    case MidiChannel_Channel.MIDI_CH_4:
      return "MIDI_CH_4";
    case MidiChannel_Channel.MIDI_CH_5:
      return "MIDI_CH_5";
    case MidiChannel_Channel.MIDI_CH_6:
      return "MIDI_CH_6";
    case MidiChannel_Channel.MIDI_CH_7:
      return "MIDI_CH_7";
    case MidiChannel_Channel.MIDI_CH_8:
      return "MIDI_CH_8";
    case MidiChannel_Channel.MIDI_CH_9:
      return "MIDI_CH_9";
    case MidiChannel_Channel.MIDI_CH_10:
      return "MIDI_CH_10";
    case MidiChannel_Channel.MIDI_CH_11:
      return "MIDI_CH_11";
    case MidiChannel_Channel.MIDI_CH_12:
      return "MIDI_CH_12";
    case MidiChannel_Channel.MIDI_CH_13:
      return "MIDI_CH_13";
    case MidiChannel_Channel.MIDI_CH_14:
      return "MIDI_CH_14";
    case MidiChannel_Channel.MIDI_CH_15:
      return "MIDI_CH_15";
    case MidiChannel_Channel.MIDI_CH_16:
      return "MIDI_CH_16";
    case MidiChannel_Channel.MIDI_CH_OMNI:
      return "MIDI_CH_OMNI";
    case MidiChannel_Channel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AudioConnection {
  track: TrackIdentifier | undefined;
  trackChannel: number;
  engineChannel: number;
}

export interface AudioConnectionList {
  connections: AudioConnection[];
}

export interface CvConnection {
  parameter: ParameterIdentifier | undefined;
  cvPortId: number;
}

export interface CvConnectionList {
  connections: CvConnection[];
}

export interface GateConnection {
  processor: ProcessorIdentifier | undefined;
  gatePortId: number;
  channel: number;
  noteNo: number;
}

export interface GateConnectionList {
  connections: GateConnection[];
}

export interface MidiKbdConnection {
  track: TrackIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
  rawMidi: boolean;
}

export interface MidiKbdConnectionList {
  connections: MidiKbdConnection[];
}

export interface MidiCCConnection {
  parameter: ParameterIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
  ccNumber: number;
  minRange: number;
  maxRange: number;
  relativeMode: boolean;
}

export interface MidiCCConnectionList {
  connections: MidiCCConnection[];
}

export interface MidiPCConnection {
  processor: ProcessorIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
}

export interface MidiPCConnectionList {
  connections: MidiPCConnection[];
}

export interface MidiClockSetRequest {
  port: number;
  enabled: boolean;
}

export interface OscParameterOutputList {
  path: string[];
}

export interface TransportUpdate {
  tempo?: number | undefined;
  playingMode?: PlayingMode | undefined;
  syncMode?: SyncMode | undefined;
  timeSignature?: TimeSignature | undefined;
}

export interface TrackUpdate {
  action: TrackUpdate_Action;
  track: TrackIdentifier | undefined;
}

export enum TrackUpdate_Action {
  DUMMY = 0,
  TRACK_ADDED = 1,
  TRACK_DELETED = 2,
  UNRECOGNIZED = -1,
}

export function trackUpdate_ActionFromJSON(object: any): TrackUpdate_Action {
  switch (object) {
    case 0:
    case "DUMMY":
      return TrackUpdate_Action.DUMMY;
    case 1:
    case "TRACK_ADDED":
      return TrackUpdate_Action.TRACK_ADDED;
    case 2:
    case "TRACK_DELETED":
      return TrackUpdate_Action.TRACK_DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TrackUpdate_Action.UNRECOGNIZED;
  }
}

export function trackUpdate_ActionToJSON(object: TrackUpdate_Action): string {
  switch (object) {
    case TrackUpdate_Action.DUMMY:
      return "DUMMY";
    case TrackUpdate_Action.TRACK_ADDED:
      return "TRACK_ADDED";
    case TrackUpdate_Action.TRACK_DELETED:
      return "TRACK_DELETED";
    case TrackUpdate_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProcessorUpdate {
  action: ProcessorUpdate_Action;
  processor: ProcessorIdentifier | undefined;
  parentTrack: TrackIdentifier | undefined;
}

export enum ProcessorUpdate_Action {
  DUMMY = 0,
  PROCESSOR_ADDED = 1,
  PROCESSOR_DELETED = 2,
  UNRECOGNIZED = -1,
}

export function processorUpdate_ActionFromJSON(object: any): ProcessorUpdate_Action {
  switch (object) {
    case 0:
    case "DUMMY":
      return ProcessorUpdate_Action.DUMMY;
    case 1:
    case "PROCESSOR_ADDED":
      return ProcessorUpdate_Action.PROCESSOR_ADDED;
    case 2:
    case "PROCESSOR_DELETED":
      return ProcessorUpdate_Action.PROCESSOR_DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProcessorUpdate_Action.UNRECOGNIZED;
  }
}

export function processorUpdate_ActionToJSON(object: ProcessorUpdate_Action): string {
  switch (object) {
    case ProcessorUpdate_Action.DUMMY:
      return "DUMMY";
    case ProcessorUpdate_Action.PROCESSOR_ADDED:
      return "PROCESSOR_ADDED";
    case ProcessorUpdate_Action.PROCESSOR_DELETED:
      return "PROCESSOR_DELETED";
    case ProcessorUpdate_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MidiKbdConnectionState {
  track: string;
  channel: MidiChannel | undefined;
  port: number;
  rawMidi: boolean;
}

export interface MidiCCConnectionState {
  processor: string;
  parameter: ParameterIdentifier | undefined;
  channel: MidiChannel | undefined;
  port: number;
  ccNumber: number;
  minRange: number;
  maxRange: number;
  relativeMode: boolean;
}

export interface MidiPCConnectionState {
  processor: string;
  channel: MidiChannel | undefined;
  port: number;
}

export interface MidiState {
  inputs: number;
  outputs: number;
  kbdInputConnections: MidiKbdConnectionState[];
  kbdOutputConnections: MidiKbdConnectionState[];
  ccConnections: MidiCCConnectionState[];
  pcConnections: MidiPCConnectionState[];
  enabledClockOutputs: number[];
}

export interface OscParameterState {
  processor: string;
  parameterIds: number[];
}

export interface OscState {
  enableAllProcessorOutputs: boolean;
  enabledProcessorOutputs: OscParameterState[];
}

export interface TrackAudioConnectionState {
  track: string;
  trackChannel: number;
  engineChannel: number;
}

export interface EngineState {
  sampleRate: number;
  tempo: number;
  playingMode: PlayingMode | undefined;
  syncMode: SyncMode | undefined;
  timeSignature: TimeSignature | undefined;
  clipDetectionInput: boolean;
  clipDetectionOutput: boolean;
  masterLimiter: boolean;
  usedAudioInputs: number;
  usedAudioOutputs: number;
  inputConnections: TrackAudioConnectionState[];
  outputConnections: TrackAudioConnectionState[];
}

export interface PluginClass {
  name: string;
  label: string;
  uid: string;
  path: string;
  type: PluginType | undefined;
  state: ProcessorState | undefined;
}

export interface TrackState {
  name: string;
  label: string;
  channels: number;
  buses: number;
  type: TrackType | undefined;
  trackState: ProcessorState | undefined;
  processors: PluginClass[];
}

export interface SessionState {
  sushiInfo: SushiBuildInfo | undefined;
  saveDate: string;
  oscState: OscState | undefined;
  midiState: MidiState | undefined;
  engineState: EngineState | undefined;
  tracks: TrackState[];
}

function createBaseGenericVoidValue(): GenericVoidValue {
  return {};
}

export const GenericVoidValue: MessageFns<GenericVoidValue> = {
  encode(_: GenericVoidValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericVoidValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericVoidValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenericVoidValue {
    return {};
  },

  toJSON(_: GenericVoidValue): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericVoidValue>, I>>(base?: I): GenericVoidValue {
    return GenericVoidValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericVoidValue>, I>>(_: I): GenericVoidValue {
    const message = createBaseGenericVoidValue();
    return message;
  },
};

function createBaseGenericFloatValue(): GenericFloatValue {
  return { value: 0 };
}

export const GenericFloatValue: MessageFns<GenericFloatValue> = {
  encode(message: GenericFloatValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericFloatValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericFloatValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericFloatValue {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: GenericFloatValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericFloatValue>, I>>(base?: I): GenericFloatValue {
    return GenericFloatValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericFloatValue>, I>>(object: I): GenericFloatValue {
    const message = createBaseGenericFloatValue();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGenericIntValue(): GenericIntValue {
  return { value: 0 };
}

export const GenericIntValue: MessageFns<GenericIntValue> = {
  encode(message: GenericIntValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericIntValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericIntValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericIntValue {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: GenericIntValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericIntValue>, I>>(base?: I): GenericIntValue {
    return GenericIntValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericIntValue>, I>>(object: I): GenericIntValue {
    const message = createBaseGenericIntValue();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGenericBoolValue(): GenericBoolValue {
  return { value: false };
}

export const GenericBoolValue: MessageFns<GenericBoolValue> = {
  encode(message: GenericBoolValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericBoolValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericBoolValue {
    return { value: isSet(object.value) ? globalThis.Boolean(object.value) : false };
  },

  toJSON(message: GenericBoolValue): unknown {
    const obj: any = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericBoolValue>, I>>(base?: I): GenericBoolValue {
    return GenericBoolValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericBoolValue>, I>>(object: I): GenericBoolValue {
    const message = createBaseGenericBoolValue();
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseGenericStringValue(): GenericStringValue {
  return { value: "" };
}

export const GenericStringValue: MessageFns<GenericStringValue> = {
  encode(message: GenericStringValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericStringValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericStringValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: GenericStringValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericStringValue>, I>>(base?: I): GenericStringValue {
    return GenericStringValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericStringValue>, I>>(object: I): GenericStringValue {
    const message = createBaseGenericStringValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOptionalBoolValue(): OptionalBoolValue {
  return { hasValue: false, value: false };
}

export const OptionalBoolValue: MessageFns<OptionalBoolValue> = {
  encode(message: OptionalBoolValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasValue !== false) {
      writer.uint32(8).bool(message.hasValue);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionalBoolValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionalBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasValue = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionalBoolValue {
    return {
      hasValue: isSet(object.hasValue) ? globalThis.Boolean(object.hasValue) : false,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: OptionalBoolValue): unknown {
    const obj: any = {};
    if (message.hasValue !== false) {
      obj.hasValue = message.hasValue;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OptionalBoolValue>, I>>(base?: I): OptionalBoolValue {
    return OptionalBoolValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionalBoolValue>, I>>(object: I): OptionalBoolValue {
    const message = createBaseOptionalBoolValue();
    message.hasValue = object.hasValue ?? false;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseOptionalIntValue(): OptionalIntValue {
  return { hasValue: false, value: 0 };
}

export const OptionalIntValue: MessageFns<OptionalIntValue> = {
  encode(message: OptionalIntValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasValue !== false) {
      writer.uint32(8).bool(message.hasValue);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionalIntValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionalIntValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasValue = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionalIntValue {
    return {
      hasValue: isSet(object.hasValue) ? globalThis.Boolean(object.hasValue) : false,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: OptionalIntValue): unknown {
    const obj: any = {};
    if (message.hasValue !== false) {
      obj.hasValue = message.hasValue;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OptionalIntValue>, I>>(base?: I): OptionalIntValue {
    return OptionalIntValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionalIntValue>, I>>(object: I): OptionalIntValue {
    const message = createBaseOptionalIntValue();
    message.hasValue = object.hasValue ?? false;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSushiBuildInfo(): SushiBuildInfo {
  return { version: "", buildOptions: [], audioBufferSize: 0, commitHash: "", buildDate: "" };
}

export const SushiBuildInfo: MessageFns<SushiBuildInfo> = {
  encode(message: SushiBuildInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.buildOptions) {
      writer.uint32(18).string(v!);
    }
    if (message.audioBufferSize !== 0) {
      writer.uint32(24).int32(message.audioBufferSize);
    }
    if (message.commitHash !== "") {
      writer.uint32(34).string(message.commitHash);
    }
    if (message.buildDate !== "") {
      writer.uint32(42).string(message.buildDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SushiBuildInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSushiBuildInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buildOptions.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.audioBufferSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commitHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buildDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SushiBuildInfo {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      buildOptions: globalThis.Array.isArray(object?.buildOptions)
        ? object.buildOptions.map((e: any) => globalThis.String(e))
        : [],
      audioBufferSize: isSet(object.audioBufferSize) ? globalThis.Number(object.audioBufferSize) : 0,
      commitHash: isSet(object.commitHash) ? globalThis.String(object.commitHash) : "",
      buildDate: isSet(object.buildDate) ? globalThis.String(object.buildDate) : "",
    };
  },

  toJSON(message: SushiBuildInfo): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.buildOptions?.length) {
      obj.buildOptions = message.buildOptions;
    }
    if (message.audioBufferSize !== 0) {
      obj.audioBufferSize = Math.round(message.audioBufferSize);
    }
    if (message.commitHash !== "") {
      obj.commitHash = message.commitHash;
    }
    if (message.buildDate !== "") {
      obj.buildDate = message.buildDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SushiBuildInfo>, I>>(base?: I): SushiBuildInfo {
    return SushiBuildInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SushiBuildInfo>, I>>(object: I): SushiBuildInfo {
    const message = createBaseSushiBuildInfo();
    message.version = object.version ?? "";
    message.buildOptions = object.buildOptions?.map((e) => e) || [];
    message.audioBufferSize = object.audioBufferSize ?? 0;
    message.commitHash = object.commitHash ?? "";
    message.buildDate = object.buildDate ?? "";
    return message;
  },
};

function createBaseTrackIdentifier(): TrackIdentifier {
  return { id: 0 };
}

export const TrackIdentifier: MessageFns<TrackIdentifier> = {
  encode(message: TrackIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackIdentifier {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: TrackIdentifier): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackIdentifier>, I>>(base?: I): TrackIdentifier {
    return TrackIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackIdentifier>, I>>(object: I): TrackIdentifier {
    const message = createBaseTrackIdentifier();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseProcessorIdentifier(): ProcessorIdentifier {
  return { id: 0 };
}

export const ProcessorIdentifier: MessageFns<ProcessorIdentifier> = {
  encode(message: ProcessorIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorIdentifier {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: ProcessorIdentifier): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorIdentifier>, I>>(base?: I): ProcessorIdentifier {
    return ProcessorIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorIdentifier>, I>>(object: I): ProcessorIdentifier {
    const message = createBaseProcessorIdentifier();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseParameterIdentifier(): ParameterIdentifier {
  return { processorId: 0, parameterId: 0 };
}

export const ParameterIdentifier: MessageFns<ParameterIdentifier> = {
  encode(message: ParameterIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processorId !== 0) {
      writer.uint32(8).int32(message.processorId);
    }
    if (message.parameterId !== 0) {
      writer.uint32(16).int32(message.parameterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.parameterId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterIdentifier {
    return {
      processorId: isSet(object.processorId) ? globalThis.Number(object.processorId) : 0,
      parameterId: isSet(object.parameterId) ? globalThis.Number(object.parameterId) : 0,
    };
  },

  toJSON(message: ParameterIdentifier): unknown {
    const obj: any = {};
    if (message.processorId !== 0) {
      obj.processorId = Math.round(message.processorId);
    }
    if (message.parameterId !== 0) {
      obj.parameterId = Math.round(message.parameterId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterIdentifier>, I>>(base?: I): ParameterIdentifier {
    return ParameterIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterIdentifier>, I>>(object: I): ParameterIdentifier {
    const message = createBaseParameterIdentifier();
    message.processorId = object.processorId ?? 0;
    message.parameterId = object.parameterId ?? 0;
    return message;
  },
};

function createBasePropertyIdentifier(): PropertyIdentifier {
  return { processorId: 0, propertyId: 0 };
}

export const PropertyIdentifier: MessageFns<PropertyIdentifier> = {
  encode(message: PropertyIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processorId !== 0) {
      writer.uint32(8).int32(message.processorId);
    }
    if (message.propertyId !== 0) {
      writer.uint32(16).int32(message.propertyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.propertyId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyIdentifier {
    return {
      processorId: isSet(object.processorId) ? globalThis.Number(object.processorId) : 0,
      propertyId: isSet(object.propertyId) ? globalThis.Number(object.propertyId) : 0,
    };
  },

  toJSON(message: PropertyIdentifier): unknown {
    const obj: any = {};
    if (message.processorId !== 0) {
      obj.processorId = Math.round(message.processorId);
    }
    if (message.propertyId !== 0) {
      obj.propertyId = Math.round(message.propertyId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyIdentifier>, I>>(base?: I): PropertyIdentifier {
    return PropertyIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyIdentifier>, I>>(object: I): PropertyIdentifier {
    const message = createBasePropertyIdentifier();
    message.processorId = object.processorId ?? 0;
    message.propertyId = object.propertyId ?? 0;
    return message;
  },
};

function createBaseParameterType(): ParameterType {
  return { type: 0 };
}

export const ParameterType: MessageFns<ParameterType> = {
  encode(message: ParameterType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterType {
    return { type: isSet(object.type) ? parameterType_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: ParameterType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = parameterType_TypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterType>, I>>(base?: I): ParameterType {
    return ParameterType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterType>, I>>(object: I): ParameterType {
    const message = createBaseParameterType();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBasePlayingMode(): PlayingMode {
  return { mode: 0 };
}

export const PlayingMode: MessageFns<PlayingMode> = {
  encode(message: PlayingMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayingMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayingMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayingMode {
    return { mode: isSet(object.mode) ? playingMode_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: PlayingMode): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = playingMode_ModeToJSON(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayingMode>, I>>(base?: I): PlayingMode {
    return PlayingMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayingMode>, I>>(object: I): PlayingMode {
    const message = createBasePlayingMode();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSyncMode(): SyncMode {
  return { mode: 0 };
}

export const SyncMode: MessageFns<SyncMode> = {
  encode(message: SyncMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncMode {
    return { mode: isSet(object.mode) ? syncMode_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: SyncMode): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = syncMode_ModeToJSON(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncMode>, I>>(base?: I): SyncMode {
    return SyncMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncMode>, I>>(object: I): SyncMode {
    const message = createBaseSyncMode();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseTimeSignature(): TimeSignature {
  return { numerator: 0, denominator: 0 };
}

export const TimeSignature: MessageFns<TimeSignature> = {
  encode(message: TimeSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numerator !== 0) {
      writer.uint32(8).int32(message.numerator);
    }
    if (message.denominator !== 0) {
      writer.uint32(16).int32(message.denominator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numerator = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.denominator = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSignature {
    return {
      numerator: isSet(object.numerator) ? globalThis.Number(object.numerator) : 0,
      denominator: isSet(object.denominator) ? globalThis.Number(object.denominator) : 0,
    };
  },

  toJSON(message: TimeSignature): unknown {
    const obj: any = {};
    if (message.numerator !== 0) {
      obj.numerator = Math.round(message.numerator);
    }
    if (message.denominator !== 0) {
      obj.denominator = Math.round(message.denominator);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeSignature>, I>>(base?: I): TimeSignature {
    return TimeSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeSignature>, I>>(object: I): TimeSignature {
    const message = createBaseTimeSignature();
    message.numerator = object.numerator ?? 0;
    message.denominator = object.denominator ?? 0;
    return message;
  },
};

function createBaseCpuTimings(): CpuTimings {
  return { average: 0, min: 0, max: 0 };
}

export const CpuTimings: MessageFns<CpuTimings> = {
  encode(message: CpuTimings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.average !== 0) {
      writer.uint32(13).float(message.average);
    }
    if (message.min !== 0) {
      writer.uint32(21).float(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(29).float(message.max);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CpuTimings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCpuTimings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.average = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.min = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.max = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CpuTimings {
    return {
      average: isSet(object.average) ? globalThis.Number(object.average) : 0,
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
    };
  },

  toJSON(message: CpuTimings): unknown {
    const obj: any = {};
    if (message.average !== 0) {
      obj.average = message.average;
    }
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CpuTimings>, I>>(base?: I): CpuTimings {
    return CpuTimings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CpuTimings>, I>>(object: I): CpuTimings {
    const message = createBaseCpuTimings();
    message.average = object.average ?? 0;
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    return message;
  },
};

function createBaseNoteOnRequest(): NoteOnRequest {
  return { track: undefined, channel: 0, note: 0, velocity: 0 };
}

export const NoteOnRequest: MessageFns<NoteOnRequest> = {
  encode(message: NoteOnRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.note !== 0) {
      writer.uint32(24).int32(message.note);
    }
    if (message.velocity !== 0) {
      writer.uint32(37).float(message.velocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteOnRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteOnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.note = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.velocity = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteOnRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      note: isSet(object.note) ? globalThis.Number(object.note) : 0,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
    };
  },

  toJSON(message: NoteOnRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.note !== 0) {
      obj.note = Math.round(message.note);
    }
    if (message.velocity !== 0) {
      obj.velocity = message.velocity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteOnRequest>, I>>(base?: I): NoteOnRequest {
    return NoteOnRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteOnRequest>, I>>(object: I): NoteOnRequest {
    const message = createBaseNoteOnRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.note = object.note ?? 0;
    message.velocity = object.velocity ?? 0;
    return message;
  },
};

function createBaseNoteOffRequest(): NoteOffRequest {
  return { track: undefined, channel: 0, note: 0, velocity: 0 };
}

export const NoteOffRequest: MessageFns<NoteOffRequest> = {
  encode(message: NoteOffRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.note !== 0) {
      writer.uint32(24).int32(message.note);
    }
    if (message.velocity !== 0) {
      writer.uint32(37).float(message.velocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteOffRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteOffRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.note = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.velocity = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteOffRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      note: isSet(object.note) ? globalThis.Number(object.note) : 0,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
    };
  },

  toJSON(message: NoteOffRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.note !== 0) {
      obj.note = Math.round(message.note);
    }
    if (message.velocity !== 0) {
      obj.velocity = message.velocity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteOffRequest>, I>>(base?: I): NoteOffRequest {
    return NoteOffRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteOffRequest>, I>>(object: I): NoteOffRequest {
    const message = createBaseNoteOffRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.note = object.note ?? 0;
    message.velocity = object.velocity ?? 0;
    return message;
  },
};

function createBaseNoteAftertouchRequest(): NoteAftertouchRequest {
  return { track: undefined, channel: 0, note: 0, value: 0 };
}

export const NoteAftertouchRequest: MessageFns<NoteAftertouchRequest> = {
  encode(message: NoteAftertouchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.note !== 0) {
      writer.uint32(24).int32(message.note);
    }
    if (message.value !== 0) {
      writer.uint32(37).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteAftertouchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteAftertouchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.note = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteAftertouchRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      note: isSet(object.note) ? globalThis.Number(object.note) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: NoteAftertouchRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.note !== 0) {
      obj.note = Math.round(message.note);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteAftertouchRequest>, I>>(base?: I): NoteAftertouchRequest {
    return NoteAftertouchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteAftertouchRequest>, I>>(object: I): NoteAftertouchRequest {
    const message = createBaseNoteAftertouchRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.note = object.note ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseNoteModulationRequest(): NoteModulationRequest {
  return { track: undefined, channel: 0, value: 0 };
}

export const NoteModulationRequest: MessageFns<NoteModulationRequest> = {
  encode(message: NoteModulationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteModulationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteModulationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteModulationRequest {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: NoteModulationRequest): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteModulationRequest>, I>>(base?: I): NoteModulationRequest {
    return NoteModulationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteModulationRequest>, I>>(object: I): NoteModulationRequest {
    const message = createBaseNoteModulationRequest();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = object.channel ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseTrackType(): TrackType {
  return { type: 0 };
}

export const TrackType: MessageFns<TrackType> = {
  encode(message: TrackType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackType {
    return { type: isSet(object.type) ? trackType_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: TrackType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = trackType_TypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackType>, I>>(base?: I): TrackType {
    return TrackType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackType>, I>>(object: I): TrackType {
    const message = createBaseTrackType();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseTrackInfo(): TrackInfo {
  return { id: 0, label: "", name: "", channels: 0, buses: 0, type: undefined, processors: [] };
}

export const TrackInfo: MessageFns<TrackInfo> = {
  encode(message: TrackInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.channels !== 0) {
      writer.uint32(32).int32(message.channels);
    }
    if (message.buses !== 0) {
      writer.uint32(40).int32(message.buses);
    }
    if (message.type !== undefined) {
      TrackType.encode(message.type, writer.uint32(50).fork()).join();
    }
    for (const v of message.processors) {
      ProcessorIdentifier.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channels = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.buses = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = TrackType.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.processors.push(ProcessorIdentifier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
      buses: isSet(object.buses) ? globalThis.Number(object.buses) : 0,
      type: isSet(object.type) ? TrackType.fromJSON(object.type) : undefined,
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => ProcessorIdentifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrackInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    if (message.buses !== 0) {
      obj.buses = Math.round(message.buses);
    }
    if (message.type !== undefined) {
      obj.type = TrackType.toJSON(message.type);
    }
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => ProcessorIdentifier.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackInfo>, I>>(base?: I): TrackInfo {
    return TrackInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackInfo>, I>>(object: I): TrackInfo {
    const message = createBaseTrackInfo();
    message.id = object.id ?? 0;
    message.label = object.label ?? "";
    message.name = object.name ?? "";
    message.channels = object.channels ?? 0;
    message.buses = object.buses ?? 0;
    message.type = (object.type !== undefined && object.type !== null) ? TrackType.fromPartial(object.type) : undefined;
    message.processors = object.processors?.map((e) => ProcessorIdentifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrackInfoList(): TrackInfoList {
  return { tracks: [] };
}

export const TrackInfoList: MessageFns<TrackInfoList> = {
  encode(message: TrackInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tracks) {
      TrackInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tracks.push(TrackInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackInfoList {
    return {
      tracks: globalThis.Array.isArray(object?.tracks) ? object.tracks.map((e: any) => TrackInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: TrackInfoList): unknown {
    const obj: any = {};
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => TrackInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackInfoList>, I>>(base?: I): TrackInfoList {
    return TrackInfoList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackInfoList>, I>>(object: I): TrackInfoList {
    const message = createBaseTrackInfoList();
    message.tracks = object.tracks?.map((e) => TrackInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessorInfo(): ProcessorInfo {
  return { id: 0, label: "", name: "", parameterCount: 0, programCount: 0 };
}

export const ProcessorInfo: MessageFns<ProcessorInfo> = {
  encode(message: ProcessorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.parameterCount !== 0) {
      writer.uint32(32).int32(message.parameterCount);
    }
    if (message.programCount !== 0) {
      writer.uint32(40).int32(message.programCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parameterCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.programCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parameterCount: isSet(object.parameterCount) ? globalThis.Number(object.parameterCount) : 0,
      programCount: isSet(object.programCount) ? globalThis.Number(object.programCount) : 0,
    };
  },

  toJSON(message: ProcessorInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parameterCount !== 0) {
      obj.parameterCount = Math.round(message.parameterCount);
    }
    if (message.programCount !== 0) {
      obj.programCount = Math.round(message.programCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorInfo>, I>>(base?: I): ProcessorInfo {
    return ProcessorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorInfo>, I>>(object: I): ProcessorInfo {
    const message = createBaseProcessorInfo();
    message.id = object.id ?? 0;
    message.label = object.label ?? "";
    message.name = object.name ?? "";
    message.parameterCount = object.parameterCount ?? 0;
    message.programCount = object.programCount ?? 0;
    return message;
  },
};

function createBaseProcessorInfoList(): ProcessorInfoList {
  return { processors: [] };
}

export const ProcessorInfoList: MessageFns<ProcessorInfoList> = {
  encode(message: ProcessorInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.processors) {
      ProcessorInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processors.push(ProcessorInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorInfoList {
    return {
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => ProcessorInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessorInfoList): unknown {
    const obj: any = {};
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => ProcessorInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorInfoList>, I>>(base?: I): ProcessorInfoList {
    return ProcessorInfoList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorInfoList>, I>>(object: I): ProcessorInfoList {
    const message = createBaseProcessorInfoList();
    message.processors = object.processors?.map((e) => ProcessorInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProgramIdentifier(): ProgramIdentifier {
  return { program: 0 };
}

export const ProgramIdentifier: MessageFns<ProgramIdentifier> = {
  encode(message: ProgramIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.program !== 0) {
      writer.uint32(8).int32(message.program);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.program = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramIdentifier {
    return { program: isSet(object.program) ? globalThis.Number(object.program) : 0 };
  },

  toJSON(message: ProgramIdentifier): unknown {
    const obj: any = {};
    if (message.program !== 0) {
      obj.program = Math.round(message.program);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgramIdentifier>, I>>(base?: I): ProgramIdentifier {
    return ProgramIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgramIdentifier>, I>>(object: I): ProgramIdentifier {
    const message = createBaseProgramIdentifier();
    message.program = object.program ?? 0;
    return message;
  },
};

function createBaseProcessorProgramIdentifier(): ProcessorProgramIdentifier {
  return { processor: undefined, program: 0 };
}

export const ProcessorProgramIdentifier: MessageFns<ProcessorProgramIdentifier> = {
  encode(message: ProcessorProgramIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.program !== 0) {
      writer.uint32(16).int32(message.program);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorProgramIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorProgramIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.program = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorProgramIdentifier {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      program: isSet(object.program) ? globalThis.Number(object.program) : 0,
    };
  },

  toJSON(message: ProcessorProgramIdentifier): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.program !== 0) {
      obj.program = Math.round(message.program);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorProgramIdentifier>, I>>(base?: I): ProcessorProgramIdentifier {
    return ProcessorProgramIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorProgramIdentifier>, I>>(object: I): ProcessorProgramIdentifier {
    const message = createBaseProcessorProgramIdentifier();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.program = object.program ?? 0;
    return message;
  },
};

function createBaseProgramInfo(): ProgramInfo {
  return { id: undefined, name: "" };
}

export const ProgramInfo: MessageFns<ProgramInfo> = {
  encode(message: ProgramInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ProgramIdentifier.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = ProgramIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramInfo {
    return {
      id: isSet(object.id) ? ProgramIdentifier.fromJSON(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: ProgramInfo): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ProgramIdentifier.toJSON(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgramInfo>, I>>(base?: I): ProgramInfo {
    return ProgramInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgramInfo>, I>>(object: I): ProgramInfo {
    const message = createBaseProgramInfo();
    message.id = (object.id !== undefined && object.id !== null) ? ProgramIdentifier.fromPartial(object.id) : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseProgramInfoList(): ProgramInfoList {
  return { programs: [] };
}

export const ProgramInfoList: MessageFns<ProgramInfoList> = {
  encode(message: ProgramInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.programs) {
      ProgramInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programs.push(ProgramInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramInfoList {
    return {
      programs: globalThis.Array.isArray(object?.programs)
        ? object.programs.map((e: any) => ProgramInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProgramInfoList): unknown {
    const obj: any = {};
    if (message.programs?.length) {
      obj.programs = message.programs.map((e) => ProgramInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgramInfoList>, I>>(base?: I): ProgramInfoList {
    return ProgramInfoList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgramInfoList>, I>>(object: I): ProgramInfoList {
    const message = createBaseProgramInfoList();
    message.programs = object.programs?.map((e) => ProgramInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessorProgramSetRequest(): ProcessorProgramSetRequest {
  return { processor: undefined, program: undefined };
}

export const ProcessorProgramSetRequest: MessageFns<ProcessorProgramSetRequest> = {
  encode(message: ProcessorProgramSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.program !== undefined) {
      ProgramIdentifier.encode(message.program, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorProgramSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorProgramSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.program = ProgramIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorProgramSetRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      program: isSet(object.program) ? ProgramIdentifier.fromJSON(object.program) : undefined,
    };
  },

  toJSON(message: ProcessorProgramSetRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.program !== undefined) {
      obj.program = ProgramIdentifier.toJSON(message.program);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorProgramSetRequest>, I>>(base?: I): ProcessorProgramSetRequest {
    return ProcessorProgramSetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorProgramSetRequest>, I>>(object: I): ProcessorProgramSetRequest {
    const message = createBaseProcessorProgramSetRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.program = (object.program !== undefined && object.program !== null)
      ? ProgramIdentifier.fromPartial(object.program)
      : undefined;
    return message;
  },
};

function createBaseProcessorBypassStateSetRequest(): ProcessorBypassStateSetRequest {
  return { processor: undefined, value: false };
}

export const ProcessorBypassStateSetRequest: MessageFns<ProcessorBypassStateSetRequest> = {
  encode(message: ProcessorBypassStateSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorBypassStateSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorBypassStateSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorBypassStateSetRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: ProcessorBypassStateSetRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorBypassStateSetRequest>, I>>(base?: I): ProcessorBypassStateSetRequest {
    return ProcessorBypassStateSetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorBypassStateSetRequest>, I>>(
    object: I,
  ): ProcessorBypassStateSetRequest {
    const message = createBaseProcessorBypassStateSetRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseProcessorState(): ProcessorState {
  return { programId: undefined, bypassed: undefined, properties: [], parameters: [], binaryData: new Uint8Array(0) };
}

export const ProcessorState: MessageFns<ProcessorState> = {
  encode(message: ProcessorState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programId !== undefined) {
      OptionalIntValue.encode(message.programId, writer.uint32(10).fork()).join();
    }
    if (message.bypassed !== undefined) {
      OptionalBoolValue.encode(message.bypassed, writer.uint32(18).fork()).join();
    }
    for (const v of message.properties) {
      PropertyValue.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.parameters) {
      ParameterValue.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.binaryData.length !== 0) {
      writer.uint32(42).bytes(message.binaryData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.programId = OptionalIntValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bypassed = OptionalBoolValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.properties.push(PropertyValue.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameters.push(ParameterValue.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.binaryData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorState {
    return {
      programId: isSet(object.programId) ? OptionalIntValue.fromJSON(object.programId) : undefined,
      bypassed: isSet(object.bypassed) ? OptionalBoolValue.fromJSON(object.bypassed) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertyValue.fromJSON(e))
        : [],
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterValue.fromJSON(e))
        : [],
      binaryData: isSet(object.binaryData) ? bytesFromBase64(object.binaryData) : new Uint8Array(0),
    };
  },

  toJSON(message: ProcessorState): unknown {
    const obj: any = {};
    if (message.programId !== undefined) {
      obj.programId = OptionalIntValue.toJSON(message.programId);
    }
    if (message.bypassed !== undefined) {
      obj.bypassed = OptionalBoolValue.toJSON(message.bypassed);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertyValue.toJSON(e));
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ParameterValue.toJSON(e));
    }
    if (message.binaryData.length !== 0) {
      obj.binaryData = base64FromBytes(message.binaryData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorState>, I>>(base?: I): ProcessorState {
    return ProcessorState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorState>, I>>(object: I): ProcessorState {
    const message = createBaseProcessorState();
    message.programId = (object.programId !== undefined && object.programId !== null)
      ? OptionalIntValue.fromPartial(object.programId)
      : undefined;
    message.bypassed = (object.bypassed !== undefined && object.bypassed !== null)
      ? OptionalBoolValue.fromPartial(object.bypassed)
      : undefined;
    message.properties = object.properties?.map((e) => PropertyValue.fromPartial(e)) || [];
    message.parameters = object.parameters?.map((e) => ParameterValue.fromPartial(e)) || [];
    message.binaryData = object.binaryData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProcessorStateSetRequest(): ProcessorStateSetRequest {
  return { processor: undefined, state: undefined };
}

export const ProcessorStateSetRequest: MessageFns<ProcessorStateSetRequest> = {
  encode(message: ProcessorStateSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.state !== undefined) {
      ProcessorState.encode(message.state, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorStateSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorStateSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = ProcessorState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorStateSetRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      state: isSet(object.state) ? ProcessorState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: ProcessorStateSetRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.state !== undefined) {
      obj.state = ProcessorState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorStateSetRequest>, I>>(base?: I): ProcessorStateSetRequest {
    return ProcessorStateSetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorStateSetRequest>, I>>(object: I): ProcessorStateSetRequest {
    const message = createBaseProcessorStateSetRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ProcessorState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseParameterInfo(): ParameterInfo {
  return {
    id: 0,
    type: undefined,
    label: "",
    name: "",
    unit: "",
    automatable: false,
    minDomainValue: 0,
    maxDomainValue: 0,
  };
}

export const ParameterInfo: MessageFns<ParameterInfo> = {
  encode(message: ParameterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.type !== undefined) {
      ParameterType.encode(message.type, writer.uint32(18).fork()).join();
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.unit !== "") {
      writer.uint32(42).string(message.unit);
    }
    if (message.automatable !== false) {
      writer.uint32(48).bool(message.automatable);
    }
    if (message.minDomainValue !== 0) {
      writer.uint32(61).float(message.minDomainValue);
    }
    if (message.maxDomainValue !== 0) {
      writer.uint32(69).float(message.maxDomainValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = ParameterType.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.automatable = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.minDomainValue = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.maxDomainValue = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? ParameterType.fromJSON(object.type) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
      automatable: isSet(object.automatable) ? globalThis.Boolean(object.automatable) : false,
      minDomainValue: isSet(object.minDomainValue) ? globalThis.Number(object.minDomainValue) : 0,
      maxDomainValue: isSet(object.maxDomainValue) ? globalThis.Number(object.maxDomainValue) : 0,
    };
  },

  toJSON(message: ParameterInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== undefined) {
      obj.type = ParameterType.toJSON(message.type);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    if (message.automatable !== false) {
      obj.automatable = message.automatable;
    }
    if (message.minDomainValue !== 0) {
      obj.minDomainValue = message.minDomainValue;
    }
    if (message.maxDomainValue !== 0) {
      obj.maxDomainValue = message.maxDomainValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterInfo>, I>>(base?: I): ParameterInfo {
    return ParameterInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterInfo>, I>>(object: I): ParameterInfo {
    const message = createBaseParameterInfo();
    message.id = object.id ?? 0;
    message.type = (object.type !== undefined && object.type !== null)
      ? ParameterType.fromPartial(object.type)
      : undefined;
    message.label = object.label ?? "";
    message.name = object.name ?? "";
    message.unit = object.unit ?? "";
    message.automatable = object.automatable ?? false;
    message.minDomainValue = object.minDomainValue ?? 0;
    message.maxDomainValue = object.maxDomainValue ?? 0;
    return message;
  },
};

function createBaseParameterInfoList(): ParameterInfoList {
  return { parameters: [] };
}

export const ParameterInfoList: MessageFns<ParameterInfoList> = {
  encode(message: ParameterInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameters) {
      ParameterInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameters.push(ParameterInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterInfoList {
    return {
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ParameterInfoList): unknown {
    const obj: any = {};
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ParameterInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterInfoList>, I>>(base?: I): ParameterInfoList {
    return ParameterInfoList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterInfoList>, I>>(object: I): ParameterInfoList {
    const message = createBaseParameterInfoList();
    message.parameters = object.parameters?.map((e) => ParameterInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParameterIdRequest(): ParameterIdRequest {
  return { processor: undefined, ParameterName: "" };
}

export const ParameterIdRequest: MessageFns<ParameterIdRequest> = {
  encode(message: ParameterIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.ParameterName !== "") {
      writer.uint32(18).string(message.ParameterName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ParameterName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterIdRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      ParameterName: isSet(object.ParameterName) ? globalThis.String(object.ParameterName) : "",
    };
  },

  toJSON(message: ParameterIdRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.ParameterName !== "") {
      obj.ParameterName = message.ParameterName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterIdRequest>, I>>(base?: I): ParameterIdRequest {
    return ParameterIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterIdRequest>, I>>(object: I): ParameterIdRequest {
    const message = createBaseParameterIdRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.ParameterName = object.ParameterName ?? "";
    return message;
  },
};

function createBaseParameterValue(): ParameterValue {
  return { parameter: undefined, value: 0 };
}

export const ParameterValue: MessageFns<ParameterValue> = {
  encode(message: ParameterValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterValue {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ParameterValue): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterValue>, I>>(base?: I): ParameterValue {
    return ParameterValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterValue>, I>>(object: I): ParameterValue {
    const message = createBaseParameterValue();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseParameterUpdate(): ParameterUpdate {
  return { parameter: undefined, normalizedValue: 0, domainValue: 0, formattedValue: "" };
}

export const ParameterUpdate: MessageFns<ParameterUpdate> = {
  encode(message: ParameterUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.normalizedValue !== 0) {
      writer.uint32(21).float(message.normalizedValue);
    }
    if (message.domainValue !== 0) {
      writer.uint32(29).float(message.domainValue);
    }
    if (message.formattedValue !== "") {
      writer.uint32(34).string(message.formattedValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.normalizedValue = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.domainValue = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.formattedValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterUpdate {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      normalizedValue: isSet(object.normalizedValue) ? globalThis.Number(object.normalizedValue) : 0,
      domainValue: isSet(object.domainValue) ? globalThis.Number(object.domainValue) : 0,
      formattedValue: isSet(object.formattedValue) ? globalThis.String(object.formattedValue) : "",
    };
  },

  toJSON(message: ParameterUpdate): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.normalizedValue !== 0) {
      obj.normalizedValue = message.normalizedValue;
    }
    if (message.domainValue !== 0) {
      obj.domainValue = message.domainValue;
    }
    if (message.formattedValue !== "") {
      obj.formattedValue = message.formattedValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterUpdate>, I>>(base?: I): ParameterUpdate {
    return ParameterUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterUpdate>, I>>(object: I): ParameterUpdate {
    const message = createBaseParameterUpdate();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.normalizedValue = object.normalizedValue ?? 0;
    message.domainValue = object.domainValue ?? 0;
    message.formattedValue = object.formattedValue ?? "";
    return message;
  },
};

function createBasePropertyInfo(): PropertyInfo {
  return { id: 0, name: "", label: "" };
}

export const PropertyInfo: MessageFns<PropertyInfo> = {
  encode(message: PropertyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: PropertyInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyInfo>, I>>(base?: I): PropertyInfo {
    return PropertyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyInfo>, I>>(object: I): PropertyInfo {
    const message = createBasePropertyInfo();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBasePropertyInfoList(): PropertyInfoList {
  return { properties: [] };
}

export const PropertyInfoList: MessageFns<PropertyInfoList> = {
  encode(message: PropertyInfoList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.properties) {
      PropertyInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyInfoList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.properties.push(PropertyInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyInfoList {
    return {
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertyInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyInfoList): unknown {
    const obj: any = {};
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertyInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyInfoList>, I>>(base?: I): PropertyInfoList {
    return PropertyInfoList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyInfoList>, I>>(object: I): PropertyInfoList {
    const message = createBasePropertyInfoList();
    message.properties = object.properties?.map((e) => PropertyInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertyValue(): PropertyValue {
  return { property: undefined, value: "" };
}

export const PropertyValue: MessageFns<PropertyValue> = {
  encode(message: PropertyValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      PropertyIdentifier.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.property = PropertyIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyValue {
    return {
      property: isSet(object.property) ? PropertyIdentifier.fromJSON(object.property) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PropertyValue): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = PropertyIdentifier.toJSON(message.property);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyValue>, I>>(base?: I): PropertyValue {
    return PropertyValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyValue>, I>>(object: I): PropertyValue {
    const message = createBasePropertyValue();
    message.property = (object.property !== undefined && object.property !== null)
      ? PropertyIdentifier.fromPartial(object.property)
      : undefined;
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePropertyIdRequest(): PropertyIdRequest {
  return { processor: undefined, propertyName: "" };
}

export const PropertyIdRequest: MessageFns<PropertyIdRequest> = {
  encode(message: PropertyIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.propertyName !== "") {
      writer.uint32(18).string(message.propertyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.propertyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyIdRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      propertyName: isSet(object.propertyName) ? globalThis.String(object.propertyName) : "",
    };
  },

  toJSON(message: PropertyIdRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.propertyName !== "") {
      obj.propertyName = message.propertyName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyIdRequest>, I>>(base?: I): PropertyIdRequest {
    return PropertyIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyIdRequest>, I>>(object: I): PropertyIdRequest {
    const message = createBasePropertyIdRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.propertyName = object.propertyName ?? "";
    return message;
  },
};

function createBasePluginType(): PluginType {
  return { type: 0 };
}

export const PluginType: MessageFns<PluginType> = {
  encode(message: PluginType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginType {
    return { type: isSet(object.type) ? pluginType_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: PluginType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = pluginType_TypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginType>, I>>(base?: I): PluginType {
    return PluginType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginType>, I>>(object: I): PluginType {
    const message = createBasePluginType();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseProcessorPosition(): ProcessorPosition {
  return { addToBack: false, beforeProcessor: undefined };
}

export const ProcessorPosition: MessageFns<ProcessorPosition> = {
  encode(message: ProcessorPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addToBack !== false) {
      writer.uint32(8).bool(message.addToBack);
    }
    if (message.beforeProcessor !== undefined) {
      ProcessorIdentifier.encode(message.beforeProcessor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.addToBack = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeProcessor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorPosition {
    return {
      addToBack: isSet(object.addToBack) ? globalThis.Boolean(object.addToBack) : false,
      beforeProcessor: isSet(object.beforeProcessor) ? ProcessorIdentifier.fromJSON(object.beforeProcessor) : undefined,
    };
  },

  toJSON(message: ProcessorPosition): unknown {
    const obj: any = {};
    if (message.addToBack !== false) {
      obj.addToBack = message.addToBack;
    }
    if (message.beforeProcessor !== undefined) {
      obj.beforeProcessor = ProcessorIdentifier.toJSON(message.beforeProcessor);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorPosition>, I>>(base?: I): ProcessorPosition {
    return ProcessorPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorPosition>, I>>(object: I): ProcessorPosition {
    const message = createBaseProcessorPosition();
    message.addToBack = object.addToBack ?? false;
    message.beforeProcessor = (object.beforeProcessor !== undefined && object.beforeProcessor !== null)
      ? ProcessorIdentifier.fromPartial(object.beforeProcessor)
      : undefined;
    return message;
  },
};

function createBaseCreateTrackRequest(): CreateTrackRequest {
  return { name: "", channels: 0 };
}

export const CreateTrackRequest: MessageFns<CreateTrackRequest> = {
  encode(message: CreateTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.channels !== 0) {
      writer.uint32(16).int32(message.channels);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channels = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTrackRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
    };
  },

  toJSON(message: CreateTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTrackRequest>, I>>(base?: I): CreateTrackRequest {
    return CreateTrackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTrackRequest>, I>>(object: I): CreateTrackRequest {
    const message = createBaseCreateTrackRequest();
    message.name = object.name ?? "";
    message.channels = object.channels ?? 0;
    return message;
  },
};

function createBaseCreateMultibusTrackRequest(): CreateMultibusTrackRequest {
  return { name: "", buses: 0 };
}

export const CreateMultibusTrackRequest: MessageFns<CreateMultibusTrackRequest> = {
  encode(message: CreateMultibusTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.buses !== 0) {
      writer.uint32(16).int32(message.buses);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMultibusTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMultibusTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.buses = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMultibusTrackRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      buses: isSet(object.buses) ? globalThis.Number(object.buses) : 0,
    };
  },

  toJSON(message: CreateMultibusTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.buses !== 0) {
      obj.buses = Math.round(message.buses);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMultibusTrackRequest>, I>>(base?: I): CreateMultibusTrackRequest {
    return CreateMultibusTrackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMultibusTrackRequest>, I>>(object: I): CreateMultibusTrackRequest {
    const message = createBaseCreateMultibusTrackRequest();
    message.name = object.name ?? "";
    message.buses = object.buses ?? 0;
    return message;
  },
};

function createBaseCreatePreTrackRequest(): CreatePreTrackRequest {
  return { name: "" };
}

export const CreatePreTrackRequest: MessageFns<CreatePreTrackRequest> = {
  encode(message: CreatePreTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePreTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePreTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePreTrackRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreatePreTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePreTrackRequest>, I>>(base?: I): CreatePreTrackRequest {
    return CreatePreTrackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePreTrackRequest>, I>>(object: I): CreatePreTrackRequest {
    const message = createBaseCreatePreTrackRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreatePostTrackRequest(): CreatePostTrackRequest {
  return { name: "" };
}

export const CreatePostTrackRequest: MessageFns<CreatePostTrackRequest> = {
  encode(message: CreatePostTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePostTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePostTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePostTrackRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreatePostTrackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePostTrackRequest>, I>>(base?: I): CreatePostTrackRequest {
    return CreatePostTrackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePostTrackRequest>, I>>(object: I): CreatePostTrackRequest {
    const message = createBaseCreatePostTrackRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateProcessorRequest(): CreateProcessorRequest {
  return { name: "", uid: "", path: "", type: undefined, track: undefined, position: undefined };
}

export const CreateProcessorRequest: MessageFns<CreateProcessorRequest> = {
  encode(message: CreateProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.type !== undefined) {
      PluginType.encode(message.type, writer.uint32(34).fork()).join();
    }
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(42).fork()).join();
    }
    if (message.position !== undefined) {
      ProcessorPosition.encode(message.position, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = PluginType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.position = ProcessorPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProcessorRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      type: isSet(object.type) ? PluginType.fromJSON(object.type) : undefined,
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      position: isSet(object.position) ? ProcessorPosition.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: CreateProcessorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.type !== undefined) {
      obj.type = PluginType.toJSON(message.type);
    }
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.position !== undefined) {
      obj.position = ProcessorPosition.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProcessorRequest>, I>>(base?: I): CreateProcessorRequest {
    return CreateProcessorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProcessorRequest>, I>>(object: I): CreateProcessorRequest {
    const message = createBaseCreateProcessorRequest();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.path = object.path ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? PluginType.fromPartial(object.type)
      : undefined;
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? ProcessorPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseMoveProcessorRequest(): MoveProcessorRequest {
  return { processor: undefined, sourceTrack: undefined, destTrack: undefined, position: undefined };
}

export const MoveProcessorRequest: MessageFns<MoveProcessorRequest> = {
  encode(message: MoveProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.sourceTrack !== undefined) {
      TrackIdentifier.encode(message.sourceTrack, writer.uint32(18).fork()).join();
    }
    if (message.destTrack !== undefined) {
      TrackIdentifier.encode(message.destTrack, writer.uint32(26).fork()).join();
    }
    if (message.position !== undefined) {
      ProcessorPosition.encode(message.position, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceTrack = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destTrack = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = ProcessorPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveProcessorRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      sourceTrack: isSet(object.sourceTrack) ? TrackIdentifier.fromJSON(object.sourceTrack) : undefined,
      destTrack: isSet(object.destTrack) ? TrackIdentifier.fromJSON(object.destTrack) : undefined,
      position: isSet(object.position) ? ProcessorPosition.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: MoveProcessorRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.sourceTrack !== undefined) {
      obj.sourceTrack = TrackIdentifier.toJSON(message.sourceTrack);
    }
    if (message.destTrack !== undefined) {
      obj.destTrack = TrackIdentifier.toJSON(message.destTrack);
    }
    if (message.position !== undefined) {
      obj.position = ProcessorPosition.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveProcessorRequest>, I>>(base?: I): MoveProcessorRequest {
    return MoveProcessorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveProcessorRequest>, I>>(object: I): MoveProcessorRequest {
    const message = createBaseMoveProcessorRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.sourceTrack = (object.sourceTrack !== undefined && object.sourceTrack !== null)
      ? TrackIdentifier.fromPartial(object.sourceTrack)
      : undefined;
    message.destTrack = (object.destTrack !== undefined && object.destTrack !== null)
      ? TrackIdentifier.fromPartial(object.destTrack)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? ProcessorPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseDeleteProcessorRequest(): DeleteProcessorRequest {
  return { processor: undefined, track: undefined };
}

export const DeleteProcessorRequest: MessageFns<DeleteProcessorRequest> = {
  encode(message: DeleteProcessorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProcessorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProcessorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProcessorRequest {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
    };
  },

  toJSON(message: DeleteProcessorRequest): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProcessorRequest>, I>>(base?: I): DeleteProcessorRequest {
    return DeleteProcessorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProcessorRequest>, I>>(object: I): DeleteProcessorRequest {
    const message = createBaseDeleteProcessorRequest();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    return message;
  },
};

function createBaseParameterNotificationBlocklist(): ParameterNotificationBlocklist {
  return { parameters: [] };
}

export const ParameterNotificationBlocklist: MessageFns<ParameterNotificationBlocklist> = {
  encode(message: ParameterNotificationBlocklist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameters) {
      ParameterIdentifier.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterNotificationBlocklist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterNotificationBlocklist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameters.push(ParameterIdentifier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterNotificationBlocklist {
    return {
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ParameterIdentifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ParameterNotificationBlocklist): unknown {
    const obj: any = {};
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ParameterIdentifier.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterNotificationBlocklist>, I>>(base?: I): ParameterNotificationBlocklist {
    return ParameterNotificationBlocklist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterNotificationBlocklist>, I>>(
    object: I,
  ): ParameterNotificationBlocklist {
    const message = createBaseParameterNotificationBlocklist();
    message.parameters = object.parameters?.map((e) => ParameterIdentifier.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertyNotificationBlocklist(): PropertyNotificationBlocklist {
  return { properties: [] };
}

export const PropertyNotificationBlocklist: MessageFns<PropertyNotificationBlocklist> = {
  encode(message: PropertyNotificationBlocklist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.properties) {
      PropertyIdentifier.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyNotificationBlocklist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyNotificationBlocklist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.properties.push(PropertyIdentifier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyNotificationBlocklist {
    return {
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertyIdentifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyNotificationBlocklist): unknown {
    const obj: any = {};
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertyIdentifier.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropertyNotificationBlocklist>, I>>(base?: I): PropertyNotificationBlocklist {
    return PropertyNotificationBlocklist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropertyNotificationBlocklist>, I>>(
    object: I,
  ): PropertyNotificationBlocklist {
    const message = createBasePropertyNotificationBlocklist();
    message.properties = object.properties?.map((e) => PropertyIdentifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiChannel(): MidiChannel {
  return { channel: 0 };
}

export const MidiChannel: MessageFns<MidiChannel> = {
  encode(message: MidiChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiChannel {
    return { channel: isSet(object.channel) ? midiChannel_ChannelFromJSON(object.channel) : 0 };
  },

  toJSON(message: MidiChannel): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = midiChannel_ChannelToJSON(message.channel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiChannel>, I>>(base?: I): MidiChannel {
    return MidiChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiChannel>, I>>(object: I): MidiChannel {
    const message = createBaseMidiChannel();
    message.channel = object.channel ?? 0;
    return message;
  },
};

function createBaseAudioConnection(): AudioConnection {
  return { track: undefined, trackChannel: 0, engineChannel: 0 };
}

export const AudioConnection: MessageFns<AudioConnection> = {
  encode(message: AudioConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.trackChannel !== 0) {
      writer.uint32(16).int32(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      writer.uint32(24).int32(message.engineChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trackChannel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.engineChannel = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioConnection {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      trackChannel: isSet(object.trackChannel) ? globalThis.Number(object.trackChannel) : 0,
      engineChannel: isSet(object.engineChannel) ? globalThis.Number(object.engineChannel) : 0,
    };
  },

  toJSON(message: AudioConnection): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.trackChannel !== 0) {
      obj.trackChannel = Math.round(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      obj.engineChannel = Math.round(message.engineChannel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioConnection>, I>>(base?: I): AudioConnection {
    return AudioConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioConnection>, I>>(object: I): AudioConnection {
    const message = createBaseAudioConnection();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.trackChannel = object.trackChannel ?? 0;
    message.engineChannel = object.engineChannel ?? 0;
    return message;
  },
};

function createBaseAudioConnectionList(): AudioConnectionList {
  return { connections: [] };
}

export const AudioConnectionList: MessageFns<AudioConnectionList> = {
  encode(message: AudioConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      AudioConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(AudioConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => AudioConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudioConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => AudioConnection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioConnectionList>, I>>(base?: I): AudioConnectionList {
    return AudioConnectionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioConnectionList>, I>>(object: I): AudioConnectionList {
    const message = createBaseAudioConnectionList();
    message.connections = object.connections?.map((e) => AudioConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCvConnection(): CvConnection {
  return { parameter: undefined, cvPortId: 0 };
}

export const CvConnection: MessageFns<CvConnection> = {
  encode(message: CvConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.cvPortId !== 0) {
      writer.uint32(16).int32(message.cvPortId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CvConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCvConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cvPortId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CvConnection {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      cvPortId: isSet(object.cvPortId) ? globalThis.Number(object.cvPortId) : 0,
    };
  },

  toJSON(message: CvConnection): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.cvPortId !== 0) {
      obj.cvPortId = Math.round(message.cvPortId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CvConnection>, I>>(base?: I): CvConnection {
    return CvConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CvConnection>, I>>(object: I): CvConnection {
    const message = createBaseCvConnection();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.cvPortId = object.cvPortId ?? 0;
    return message;
  },
};

function createBaseCvConnectionList(): CvConnectionList {
  return { connections: [] };
}

export const CvConnectionList: MessageFns<CvConnectionList> = {
  encode(message: CvConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      CvConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CvConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCvConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(CvConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CvConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => CvConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CvConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => CvConnection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CvConnectionList>, I>>(base?: I): CvConnectionList {
    return CvConnectionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CvConnectionList>, I>>(object: I): CvConnectionList {
    const message = createBaseCvConnectionList();
    message.connections = object.connections?.map((e) => CvConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGateConnection(): GateConnection {
  return { processor: undefined, gatePortId: 0, channel: 0, noteNo: 0 };
}

export const GateConnection: MessageFns<GateConnection> = {
  encode(message: GateConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.gatePortId !== 0) {
      writer.uint32(16).int32(message.gatePortId);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.noteNo !== 0) {
      writer.uint32(32).int32(message.noteNo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GateConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gatePortId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noteNo = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GateConnection {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      gatePortId: isSet(object.gatePortId) ? globalThis.Number(object.gatePortId) : 0,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      noteNo: isSet(object.noteNo) ? globalThis.Number(object.noteNo) : 0,
    };
  },

  toJSON(message: GateConnection): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.gatePortId !== 0) {
      obj.gatePortId = Math.round(message.gatePortId);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.noteNo !== 0) {
      obj.noteNo = Math.round(message.noteNo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GateConnection>, I>>(base?: I): GateConnection {
    return GateConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GateConnection>, I>>(object: I): GateConnection {
    const message = createBaseGateConnection();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.gatePortId = object.gatePortId ?? 0;
    message.channel = object.channel ?? 0;
    message.noteNo = object.noteNo ?? 0;
    return message;
  },
};

function createBaseGateConnectionList(): GateConnectionList {
  return { connections: [] };
}

export const GateConnectionList: MessageFns<GateConnectionList> = {
  encode(message: GateConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      GateConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GateConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(GateConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GateConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => GateConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GateConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => GateConnection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GateConnectionList>, I>>(base?: I): GateConnectionList {
    return GateConnectionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GateConnectionList>, I>>(object: I): GateConnectionList {
    const message = createBaseGateConnectionList();
    message.connections = object.connections?.map((e) => GateConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiKbdConnection(): MidiKbdConnection {
  return { track: undefined, channel: undefined, port: 0, rawMidi: false };
}

export const MidiKbdConnection: MessageFns<MidiKbdConnection> = {
  encode(message: MidiKbdConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.rawMidi !== false) {
      writer.uint32(56).bool(message.rawMidi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiKbdConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiKbdConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rawMidi = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiKbdConnection {
    return {
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      rawMidi: isSet(object.rawMidi) ? globalThis.Boolean(object.rawMidi) : false,
    };
  },

  toJSON(message: MidiKbdConnection): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.rawMidi !== false) {
      obj.rawMidi = message.rawMidi;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiKbdConnection>, I>>(base?: I): MidiKbdConnection {
    return MidiKbdConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiKbdConnection>, I>>(object: I): MidiKbdConnection {
    const message = createBaseMidiKbdConnection();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.rawMidi = object.rawMidi ?? false;
    return message;
  },
};

function createBaseMidiKbdConnectionList(): MidiKbdConnectionList {
  return { connections: [] };
}

export const MidiKbdConnectionList: MessageFns<MidiKbdConnectionList> = {
  encode(message: MidiKbdConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      MidiKbdConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiKbdConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiKbdConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(MidiKbdConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiKbdConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiKbdConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiKbdConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiKbdConnection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiKbdConnectionList>, I>>(base?: I): MidiKbdConnectionList {
    return MidiKbdConnectionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiKbdConnectionList>, I>>(object: I): MidiKbdConnectionList {
    const message = createBaseMidiKbdConnectionList();
    message.connections = object.connections?.map((e) => MidiKbdConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiCCConnection(): MidiCCConnection {
  return {
    parameter: undefined,
    channel: undefined,
    port: 0,
    ccNumber: 0,
    minRange: 0,
    maxRange: 0,
    relativeMode: false,
  };
}

export const MidiCCConnection: MessageFns<MidiCCConnection> = {
  encode(message: MidiCCConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.ccNumber !== 0) {
      writer.uint32(32).int32(message.ccNumber);
    }
    if (message.minRange !== 0) {
      writer.uint32(45).float(message.minRange);
    }
    if (message.maxRange !== 0) {
      writer.uint32(53).float(message.maxRange);
    }
    if (message.relativeMode !== false) {
      writer.uint32(56).bool(message.relativeMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiCCConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiCCConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ccNumber = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.minRange = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.maxRange = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.relativeMode = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiCCConnection {
    return {
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      ccNumber: isSet(object.ccNumber) ? globalThis.Number(object.ccNumber) : 0,
      minRange: isSet(object.minRange) ? globalThis.Number(object.minRange) : 0,
      maxRange: isSet(object.maxRange) ? globalThis.Number(object.maxRange) : 0,
      relativeMode: isSet(object.relativeMode) ? globalThis.Boolean(object.relativeMode) : false,
    };
  },

  toJSON(message: MidiCCConnection): unknown {
    const obj: any = {};
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.ccNumber !== 0) {
      obj.ccNumber = Math.round(message.ccNumber);
    }
    if (message.minRange !== 0) {
      obj.minRange = message.minRange;
    }
    if (message.maxRange !== 0) {
      obj.maxRange = message.maxRange;
    }
    if (message.relativeMode !== false) {
      obj.relativeMode = message.relativeMode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiCCConnection>, I>>(base?: I): MidiCCConnection {
    return MidiCCConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiCCConnection>, I>>(object: I): MidiCCConnection {
    const message = createBaseMidiCCConnection();
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.ccNumber = object.ccNumber ?? 0;
    message.minRange = object.minRange ?? 0;
    message.maxRange = object.maxRange ?? 0;
    message.relativeMode = object.relativeMode ?? false;
    return message;
  },
};

function createBaseMidiCCConnectionList(): MidiCCConnectionList {
  return { connections: [] };
}

export const MidiCCConnectionList: MessageFns<MidiCCConnectionList> = {
  encode(message: MidiCCConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      MidiCCConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiCCConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiCCConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(MidiCCConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiCCConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiCCConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiCCConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiCCConnection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiCCConnectionList>, I>>(base?: I): MidiCCConnectionList {
    return MidiCCConnectionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiCCConnectionList>, I>>(object: I): MidiCCConnectionList {
    const message = createBaseMidiCCConnectionList();
    message.connections = object.connections?.map((e) => MidiCCConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiPCConnection(): MidiPCConnection {
  return { processor: undefined, channel: undefined, port: 0 };
}

export const MidiPCConnection: MessageFns<MidiPCConnection> = {
  encode(message: MidiPCConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiPCConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiPCConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiPCConnection {
    return {
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: MidiPCConnection): unknown {
    const obj: any = {};
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiPCConnection>, I>>(base?: I): MidiPCConnection {
    return MidiPCConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiPCConnection>, I>>(object: I): MidiPCConnection {
    const message = createBaseMidiPCConnection();
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseMidiPCConnectionList(): MidiPCConnectionList {
  return { connections: [] };
}

export const MidiPCConnectionList: MessageFns<MidiPCConnectionList> = {
  encode(message: MidiPCConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      MidiPCConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiPCConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiPCConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(MidiPCConnection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiPCConnectionList {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => MidiPCConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MidiPCConnectionList): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => MidiPCConnection.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiPCConnectionList>, I>>(base?: I): MidiPCConnectionList {
    return MidiPCConnectionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiPCConnectionList>, I>>(object: I): MidiPCConnectionList {
    const message = createBaseMidiPCConnectionList();
    message.connections = object.connections?.map((e) => MidiPCConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMidiClockSetRequest(): MidiClockSetRequest {
  return { port: 0, enabled: false };
}

export const MidiClockSetRequest: MessageFns<MidiClockSetRequest> = {
  encode(message: MidiClockSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== 0) {
      writer.uint32(8).int32(message.port);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiClockSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiClockSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiClockSetRequest {
    return {
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: MidiClockSetRequest): unknown {
    const obj: any = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiClockSetRequest>, I>>(base?: I): MidiClockSetRequest {
    return MidiClockSetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiClockSetRequest>, I>>(object: I): MidiClockSetRequest {
    const message = createBaseMidiClockSetRequest();
    message.port = object.port ?? 0;
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseOscParameterOutputList(): OscParameterOutputList {
  return { path: [] };
}

export const OscParameterOutputList: MessageFns<OscParameterOutputList> = {
  encode(message: OscParameterOutputList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.path) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OscParameterOutputList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOscParameterOutputList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OscParameterOutputList {
    return { path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: OscParameterOutputList): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OscParameterOutputList>, I>>(base?: I): OscParameterOutputList {
    return OscParameterOutputList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OscParameterOutputList>, I>>(object: I): OscParameterOutputList {
    const message = createBaseOscParameterOutputList();
    message.path = object.path?.map((e) => e) || [];
    return message;
  },
};

function createBaseTransportUpdate(): TransportUpdate {
  return { tempo: undefined, playingMode: undefined, syncMode: undefined, timeSignature: undefined };
}

export const TransportUpdate: MessageFns<TransportUpdate> = {
  encode(message: TransportUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tempo !== undefined) {
      writer.uint32(13).float(message.tempo);
    }
    if (message.playingMode !== undefined) {
      PlayingMode.encode(message.playingMode, writer.uint32(18).fork()).join();
    }
    if (message.syncMode !== undefined) {
      SyncMode.encode(message.syncMode, writer.uint32(26).fork()).join();
    }
    if (message.timeSignature !== undefined) {
      TimeSignature.encode(message.timeSignature, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransportUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransportUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.tempo = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playingMode = PlayingMode.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.syncMode = SyncMode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeSignature = TimeSignature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransportUpdate {
    return {
      tempo: isSet(object.tempo) ? globalThis.Number(object.tempo) : undefined,
      playingMode: isSet(object.playingMode) ? PlayingMode.fromJSON(object.playingMode) : undefined,
      syncMode: isSet(object.syncMode) ? SyncMode.fromJSON(object.syncMode) : undefined,
      timeSignature: isSet(object.timeSignature) ? TimeSignature.fromJSON(object.timeSignature) : undefined,
    };
  },

  toJSON(message: TransportUpdate): unknown {
    const obj: any = {};
    if (message.tempo !== undefined) {
      obj.tempo = message.tempo;
    }
    if (message.playingMode !== undefined) {
      obj.playingMode = PlayingMode.toJSON(message.playingMode);
    }
    if (message.syncMode !== undefined) {
      obj.syncMode = SyncMode.toJSON(message.syncMode);
    }
    if (message.timeSignature !== undefined) {
      obj.timeSignature = TimeSignature.toJSON(message.timeSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransportUpdate>, I>>(base?: I): TransportUpdate {
    return TransportUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransportUpdate>, I>>(object: I): TransportUpdate {
    const message = createBaseTransportUpdate();
    message.tempo = object.tempo ?? undefined;
    message.playingMode = (object.playingMode !== undefined && object.playingMode !== null)
      ? PlayingMode.fromPartial(object.playingMode)
      : undefined;
    message.syncMode = (object.syncMode !== undefined && object.syncMode !== null)
      ? SyncMode.fromPartial(object.syncMode)
      : undefined;
    message.timeSignature = (object.timeSignature !== undefined && object.timeSignature !== null)
      ? TimeSignature.fromPartial(object.timeSignature)
      : undefined;
    return message;
  },
};

function createBaseTrackUpdate(): TrackUpdate {
  return { action: 0, track: undefined };
}

export const TrackUpdate: MessageFns<TrackUpdate> = {
  encode(message: TrackUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.track !== undefined) {
      TrackIdentifier.encode(message.track, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.track = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackUpdate {
    return {
      action: isSet(object.action) ? trackUpdate_ActionFromJSON(object.action) : 0,
      track: isSet(object.track) ? TrackIdentifier.fromJSON(object.track) : undefined,
    };
  },

  toJSON(message: TrackUpdate): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = trackUpdate_ActionToJSON(message.action);
    }
    if (message.track !== undefined) {
      obj.track = TrackIdentifier.toJSON(message.track);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackUpdate>, I>>(base?: I): TrackUpdate {
    return TrackUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackUpdate>, I>>(object: I): TrackUpdate {
    const message = createBaseTrackUpdate();
    message.action = object.action ?? 0;
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackIdentifier.fromPartial(object.track)
      : undefined;
    return message;
  },
};

function createBaseProcessorUpdate(): ProcessorUpdate {
  return { action: 0, processor: undefined, parentTrack: undefined };
}

export const ProcessorUpdate: MessageFns<ProcessorUpdate> = {
  encode(message: ProcessorUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.processor !== undefined) {
      ProcessorIdentifier.encode(message.processor, writer.uint32(18).fork()).join();
    }
    if (message.parentTrack !== undefined) {
      TrackIdentifier.encode(message.parentTrack, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.processor = ProcessorIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentTrack = TrackIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorUpdate {
    return {
      action: isSet(object.action) ? processorUpdate_ActionFromJSON(object.action) : 0,
      processor: isSet(object.processor) ? ProcessorIdentifier.fromJSON(object.processor) : undefined,
      parentTrack: isSet(object.parentTrack) ? TrackIdentifier.fromJSON(object.parentTrack) : undefined,
    };
  },

  toJSON(message: ProcessorUpdate): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = processorUpdate_ActionToJSON(message.action);
    }
    if (message.processor !== undefined) {
      obj.processor = ProcessorIdentifier.toJSON(message.processor);
    }
    if (message.parentTrack !== undefined) {
      obj.parentTrack = TrackIdentifier.toJSON(message.parentTrack);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorUpdate>, I>>(base?: I): ProcessorUpdate {
    return ProcessorUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorUpdate>, I>>(object: I): ProcessorUpdate {
    const message = createBaseProcessorUpdate();
    message.action = object.action ?? 0;
    message.processor = (object.processor !== undefined && object.processor !== null)
      ? ProcessorIdentifier.fromPartial(object.processor)
      : undefined;
    message.parentTrack = (object.parentTrack !== undefined && object.parentTrack !== null)
      ? TrackIdentifier.fromPartial(object.parentTrack)
      : undefined;
    return message;
  },
};

function createBaseMidiKbdConnectionState(): MidiKbdConnectionState {
  return { track: "", channel: undefined, port: 0, rawMidi: false };
}

export const MidiKbdConnectionState: MessageFns<MidiKbdConnectionState> = {
  encode(message: MidiKbdConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== "") {
      writer.uint32(10).string(message.track);
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.rawMidi !== false) {
      writer.uint32(56).bool(message.rawMidi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiKbdConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiKbdConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rawMidi = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiKbdConnectionState {
    return {
      track: isSet(object.track) ? globalThis.String(object.track) : "",
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      rawMidi: isSet(object.rawMidi) ? globalThis.Boolean(object.rawMidi) : false,
    };
  },

  toJSON(message: MidiKbdConnectionState): unknown {
    const obj: any = {};
    if (message.track !== "") {
      obj.track = message.track;
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.rawMidi !== false) {
      obj.rawMidi = message.rawMidi;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiKbdConnectionState>, I>>(base?: I): MidiKbdConnectionState {
    return MidiKbdConnectionState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiKbdConnectionState>, I>>(object: I): MidiKbdConnectionState {
    const message = createBaseMidiKbdConnectionState();
    message.track = object.track ?? "";
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.rawMidi = object.rawMidi ?? false;
    return message;
  },
};

function createBaseMidiCCConnectionState(): MidiCCConnectionState {
  return {
    processor: "",
    parameter: undefined,
    channel: undefined,
    port: 0,
    ccNumber: 0,
    minRange: 0,
    maxRange: 0,
    relativeMode: false,
  };
}

export const MidiCCConnectionState: MessageFns<MidiCCConnectionState> = {
  encode(message: MidiCCConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== "") {
      writer.uint32(10).string(message.processor);
    }
    if (message.parameter !== undefined) {
      ParameterIdentifier.encode(message.parameter, writer.uint32(18).fork()).join();
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(26).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(32).int32(message.port);
    }
    if (message.ccNumber !== 0) {
      writer.uint32(40).int32(message.ccNumber);
    }
    if (message.minRange !== 0) {
      writer.uint32(53).float(message.minRange);
    }
    if (message.maxRange !== 0) {
      writer.uint32(61).float(message.maxRange);
    }
    if (message.relativeMode !== false) {
      writer.uint32(64).bool(message.relativeMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiCCConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiCCConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parameter = ParameterIdentifier.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ccNumber = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.minRange = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.maxRange = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.relativeMode = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiCCConnectionState {
    return {
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      parameter: isSet(object.parameter) ? ParameterIdentifier.fromJSON(object.parameter) : undefined,
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      ccNumber: isSet(object.ccNumber) ? globalThis.Number(object.ccNumber) : 0,
      minRange: isSet(object.minRange) ? globalThis.Number(object.minRange) : 0,
      maxRange: isSet(object.maxRange) ? globalThis.Number(object.maxRange) : 0,
      relativeMode: isSet(object.relativeMode) ? globalThis.Boolean(object.relativeMode) : false,
    };
  },

  toJSON(message: MidiCCConnectionState): unknown {
    const obj: any = {};
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.parameter !== undefined) {
      obj.parameter = ParameterIdentifier.toJSON(message.parameter);
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.ccNumber !== 0) {
      obj.ccNumber = Math.round(message.ccNumber);
    }
    if (message.minRange !== 0) {
      obj.minRange = message.minRange;
    }
    if (message.maxRange !== 0) {
      obj.maxRange = message.maxRange;
    }
    if (message.relativeMode !== false) {
      obj.relativeMode = message.relativeMode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiCCConnectionState>, I>>(base?: I): MidiCCConnectionState {
    return MidiCCConnectionState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiCCConnectionState>, I>>(object: I): MidiCCConnectionState {
    const message = createBaseMidiCCConnectionState();
    message.processor = object.processor ?? "";
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? ParameterIdentifier.fromPartial(object.parameter)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    message.ccNumber = object.ccNumber ?? 0;
    message.minRange = object.minRange ?? 0;
    message.maxRange = object.maxRange ?? 0;
    message.relativeMode = object.relativeMode ?? false;
    return message;
  },
};

function createBaseMidiPCConnectionState(): MidiPCConnectionState {
  return { processor: "", channel: undefined, port: 0 };
}

export const MidiPCConnectionState: MessageFns<MidiPCConnectionState> = {
  encode(message: MidiPCConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== "") {
      writer.uint32(10).string(message.processor);
    }
    if (message.channel !== undefined) {
      MidiChannel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiPCConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiPCConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = MidiChannel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiPCConnectionState {
    return {
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      channel: isSet(object.channel) ? MidiChannel.fromJSON(object.channel) : undefined,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: MidiPCConnectionState): unknown {
    const obj: any = {};
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.channel !== undefined) {
      obj.channel = MidiChannel.toJSON(message.channel);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiPCConnectionState>, I>>(base?: I): MidiPCConnectionState {
    return MidiPCConnectionState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiPCConnectionState>, I>>(object: I): MidiPCConnectionState {
    const message = createBaseMidiPCConnectionState();
    message.processor = object.processor ?? "";
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? MidiChannel.fromPartial(object.channel)
      : undefined;
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseMidiState(): MidiState {
  return {
    inputs: 0,
    outputs: 0,
    kbdInputConnections: [],
    kbdOutputConnections: [],
    ccConnections: [],
    pcConnections: [],
    enabledClockOutputs: [],
  };
}

export const MidiState: MessageFns<MidiState> = {
  encode(message: MidiState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputs !== 0) {
      writer.uint32(8).int32(message.inputs);
    }
    if (message.outputs !== 0) {
      writer.uint32(16).int32(message.outputs);
    }
    for (const v of message.kbdInputConnections) {
      MidiKbdConnectionState.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.kbdOutputConnections) {
      MidiKbdConnectionState.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.ccConnections) {
      MidiCCConnectionState.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.pcConnections) {
      MidiPCConnectionState.encode(v!, writer.uint32(50).fork()).join();
    }
    writer.uint32(58).fork();
    for (const v of message.enabledClockOutputs) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MidiState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMidiState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputs = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputs = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kbdInputConnections.push(MidiKbdConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kbdOutputConnections.push(MidiKbdConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ccConnections.push(MidiCCConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pcConnections.push(MidiPCConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.enabledClockOutputs.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enabledClockOutputs.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MidiState {
    return {
      inputs: isSet(object.inputs) ? globalThis.Number(object.inputs) : 0,
      outputs: isSet(object.outputs) ? globalThis.Number(object.outputs) : 0,
      kbdInputConnections: globalThis.Array.isArray(object?.kbdInputConnections)
        ? object.kbdInputConnections.map((e: any) => MidiKbdConnectionState.fromJSON(e))
        : [],
      kbdOutputConnections: globalThis.Array.isArray(object?.kbdOutputConnections)
        ? object.kbdOutputConnections.map((e: any) => MidiKbdConnectionState.fromJSON(e))
        : [],
      ccConnections: globalThis.Array.isArray(object?.ccConnections)
        ? object.ccConnections.map((e: any) => MidiCCConnectionState.fromJSON(e))
        : [],
      pcConnections: globalThis.Array.isArray(object?.pcConnections)
        ? object.pcConnections.map((e: any) => MidiPCConnectionState.fromJSON(e))
        : [],
      enabledClockOutputs: globalThis.Array.isArray(object?.enabledClockOutputs)
        ? object.enabledClockOutputs.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: MidiState): unknown {
    const obj: any = {};
    if (message.inputs !== 0) {
      obj.inputs = Math.round(message.inputs);
    }
    if (message.outputs !== 0) {
      obj.outputs = Math.round(message.outputs);
    }
    if (message.kbdInputConnections?.length) {
      obj.kbdInputConnections = message.kbdInputConnections.map((e) => MidiKbdConnectionState.toJSON(e));
    }
    if (message.kbdOutputConnections?.length) {
      obj.kbdOutputConnections = message.kbdOutputConnections.map((e) => MidiKbdConnectionState.toJSON(e));
    }
    if (message.ccConnections?.length) {
      obj.ccConnections = message.ccConnections.map((e) => MidiCCConnectionState.toJSON(e));
    }
    if (message.pcConnections?.length) {
      obj.pcConnections = message.pcConnections.map((e) => MidiPCConnectionState.toJSON(e));
    }
    if (message.enabledClockOutputs?.length) {
      obj.enabledClockOutputs = message.enabledClockOutputs.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MidiState>, I>>(base?: I): MidiState {
    return MidiState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MidiState>, I>>(object: I): MidiState {
    const message = createBaseMidiState();
    message.inputs = object.inputs ?? 0;
    message.outputs = object.outputs ?? 0;
    message.kbdInputConnections = object.kbdInputConnections?.map((e) => MidiKbdConnectionState.fromPartial(e)) || [];
    message.kbdOutputConnections = object.kbdOutputConnections?.map((e) => MidiKbdConnectionState.fromPartial(e)) || [];
    message.ccConnections = object.ccConnections?.map((e) => MidiCCConnectionState.fromPartial(e)) || [];
    message.pcConnections = object.pcConnections?.map((e) => MidiPCConnectionState.fromPartial(e)) || [];
    message.enabledClockOutputs = object.enabledClockOutputs?.map((e) => e) || [];
    return message;
  },
};

function createBaseOscParameterState(): OscParameterState {
  return { processor: "", parameterIds: [] };
}

export const OscParameterState: MessageFns<OscParameterState> = {
  encode(message: OscParameterState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== "") {
      writer.uint32(10).string(message.processor);
    }
    writer.uint32(18).fork();
    for (const v of message.parameterIds) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OscParameterState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOscParameterState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processor = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.parameterIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.parameterIds.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OscParameterState {
    return {
      processor: isSet(object.processor) ? globalThis.String(object.processor) : "",
      parameterIds: globalThis.Array.isArray(object?.parameterIds)
        ? object.parameterIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: OscParameterState): unknown {
    const obj: any = {};
    if (message.processor !== "") {
      obj.processor = message.processor;
    }
    if (message.parameterIds?.length) {
      obj.parameterIds = message.parameterIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OscParameterState>, I>>(base?: I): OscParameterState {
    return OscParameterState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OscParameterState>, I>>(object: I): OscParameterState {
    const message = createBaseOscParameterState();
    message.processor = object.processor ?? "";
    message.parameterIds = object.parameterIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOscState(): OscState {
  return { enableAllProcessorOutputs: false, enabledProcessorOutputs: [] };
}

export const OscState: MessageFns<OscState> = {
  encode(message: OscState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableAllProcessorOutputs !== false) {
      writer.uint32(8).bool(message.enableAllProcessorOutputs);
    }
    for (const v of message.enabledProcessorOutputs) {
      OscParameterState.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OscState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOscState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enableAllProcessorOutputs = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enabledProcessorOutputs.push(OscParameterState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OscState {
    return {
      enableAllProcessorOutputs: isSet(object.enableAllProcessorOutputs)
        ? globalThis.Boolean(object.enableAllProcessorOutputs)
        : false,
      enabledProcessorOutputs: globalThis.Array.isArray(object?.enabledProcessorOutputs)
        ? object.enabledProcessorOutputs.map((e: any) => OscParameterState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OscState): unknown {
    const obj: any = {};
    if (message.enableAllProcessorOutputs !== false) {
      obj.enableAllProcessorOutputs = message.enableAllProcessorOutputs;
    }
    if (message.enabledProcessorOutputs?.length) {
      obj.enabledProcessorOutputs = message.enabledProcessorOutputs.map((e) => OscParameterState.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OscState>, I>>(base?: I): OscState {
    return OscState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OscState>, I>>(object: I): OscState {
    const message = createBaseOscState();
    message.enableAllProcessorOutputs = object.enableAllProcessorOutputs ?? false;
    message.enabledProcessorOutputs = object.enabledProcessorOutputs?.map((e) => OscParameterState.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseTrackAudioConnectionState(): TrackAudioConnectionState {
  return { track: "", trackChannel: 0, engineChannel: 0 };
}

export const TrackAudioConnectionState: MessageFns<TrackAudioConnectionState> = {
  encode(message: TrackAudioConnectionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== "") {
      writer.uint32(10).string(message.track);
    }
    if (message.trackChannel !== 0) {
      writer.uint32(16).int32(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      writer.uint32(24).int32(message.engineChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackAudioConnectionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackAudioConnectionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trackChannel = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.engineChannel = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackAudioConnectionState {
    return {
      track: isSet(object.track) ? globalThis.String(object.track) : "",
      trackChannel: isSet(object.trackChannel) ? globalThis.Number(object.trackChannel) : 0,
      engineChannel: isSet(object.engineChannel) ? globalThis.Number(object.engineChannel) : 0,
    };
  },

  toJSON(message: TrackAudioConnectionState): unknown {
    const obj: any = {};
    if (message.track !== "") {
      obj.track = message.track;
    }
    if (message.trackChannel !== 0) {
      obj.trackChannel = Math.round(message.trackChannel);
    }
    if (message.engineChannel !== 0) {
      obj.engineChannel = Math.round(message.engineChannel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackAudioConnectionState>, I>>(base?: I): TrackAudioConnectionState {
    return TrackAudioConnectionState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackAudioConnectionState>, I>>(object: I): TrackAudioConnectionState {
    const message = createBaseTrackAudioConnectionState();
    message.track = object.track ?? "";
    message.trackChannel = object.trackChannel ?? 0;
    message.engineChannel = object.engineChannel ?? 0;
    return message;
  },
};

function createBaseEngineState(): EngineState {
  return {
    sampleRate: 0,
    tempo: 0,
    playingMode: undefined,
    syncMode: undefined,
    timeSignature: undefined,
    clipDetectionInput: false,
    clipDetectionOutput: false,
    masterLimiter: false,
    usedAudioInputs: 0,
    usedAudioOutputs: 0,
    inputConnections: [],
    outputConnections: [],
  };
}

export const EngineState: MessageFns<EngineState> = {
  encode(message: EngineState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleRate !== 0) {
      writer.uint32(13).float(message.sampleRate);
    }
    if (message.tempo !== 0) {
      writer.uint32(21).float(message.tempo);
    }
    if (message.playingMode !== undefined) {
      PlayingMode.encode(message.playingMode, writer.uint32(26).fork()).join();
    }
    if (message.syncMode !== undefined) {
      SyncMode.encode(message.syncMode, writer.uint32(34).fork()).join();
    }
    if (message.timeSignature !== undefined) {
      TimeSignature.encode(message.timeSignature, writer.uint32(42).fork()).join();
    }
    if (message.clipDetectionInput !== false) {
      writer.uint32(48).bool(message.clipDetectionInput);
    }
    if (message.clipDetectionOutput !== false) {
      writer.uint32(56).bool(message.clipDetectionOutput);
    }
    if (message.masterLimiter !== false) {
      writer.uint32(64).bool(message.masterLimiter);
    }
    if (message.usedAudioInputs !== 0) {
      writer.uint32(72).int32(message.usedAudioInputs);
    }
    if (message.usedAudioOutputs !== 0) {
      writer.uint32(80).int32(message.usedAudioOutputs);
    }
    for (const v of message.inputConnections) {
      TrackAudioConnectionState.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.outputConnections) {
      TrackAudioConnectionState.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.sampleRate = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.tempo = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playingMode = PlayingMode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.syncMode = SyncMode.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timeSignature = TimeSignature.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.clipDetectionInput = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.clipDetectionOutput = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.masterLimiter = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.usedAudioInputs = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.usedAudioOutputs = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.inputConnections.push(TrackAudioConnectionState.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.outputConnections.push(TrackAudioConnectionState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineState {
    return {
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
      tempo: isSet(object.tempo) ? globalThis.Number(object.tempo) : 0,
      playingMode: isSet(object.playingMode) ? PlayingMode.fromJSON(object.playingMode) : undefined,
      syncMode: isSet(object.syncMode) ? SyncMode.fromJSON(object.syncMode) : undefined,
      timeSignature: isSet(object.timeSignature) ? TimeSignature.fromJSON(object.timeSignature) : undefined,
      clipDetectionInput: isSet(object.clipDetectionInput) ? globalThis.Boolean(object.clipDetectionInput) : false,
      clipDetectionOutput: isSet(object.clipDetectionOutput) ? globalThis.Boolean(object.clipDetectionOutput) : false,
      masterLimiter: isSet(object.masterLimiter) ? globalThis.Boolean(object.masterLimiter) : false,
      usedAudioInputs: isSet(object.usedAudioInputs) ? globalThis.Number(object.usedAudioInputs) : 0,
      usedAudioOutputs: isSet(object.usedAudioOutputs) ? globalThis.Number(object.usedAudioOutputs) : 0,
      inputConnections: globalThis.Array.isArray(object?.inputConnections)
        ? object.inputConnections.map((e: any) => TrackAudioConnectionState.fromJSON(e))
        : [],
      outputConnections: globalThis.Array.isArray(object?.outputConnections)
        ? object.outputConnections.map((e: any) => TrackAudioConnectionState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EngineState): unknown {
    const obj: any = {};
    if (message.sampleRate !== 0) {
      obj.sampleRate = message.sampleRate;
    }
    if (message.tempo !== 0) {
      obj.tempo = message.tempo;
    }
    if (message.playingMode !== undefined) {
      obj.playingMode = PlayingMode.toJSON(message.playingMode);
    }
    if (message.syncMode !== undefined) {
      obj.syncMode = SyncMode.toJSON(message.syncMode);
    }
    if (message.timeSignature !== undefined) {
      obj.timeSignature = TimeSignature.toJSON(message.timeSignature);
    }
    if (message.clipDetectionInput !== false) {
      obj.clipDetectionInput = message.clipDetectionInput;
    }
    if (message.clipDetectionOutput !== false) {
      obj.clipDetectionOutput = message.clipDetectionOutput;
    }
    if (message.masterLimiter !== false) {
      obj.masterLimiter = message.masterLimiter;
    }
    if (message.usedAudioInputs !== 0) {
      obj.usedAudioInputs = Math.round(message.usedAudioInputs);
    }
    if (message.usedAudioOutputs !== 0) {
      obj.usedAudioOutputs = Math.round(message.usedAudioOutputs);
    }
    if (message.inputConnections?.length) {
      obj.inputConnections = message.inputConnections.map((e) => TrackAudioConnectionState.toJSON(e));
    }
    if (message.outputConnections?.length) {
      obj.outputConnections = message.outputConnections.map((e) => TrackAudioConnectionState.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EngineState>, I>>(base?: I): EngineState {
    return EngineState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EngineState>, I>>(object: I): EngineState {
    const message = createBaseEngineState();
    message.sampleRate = object.sampleRate ?? 0;
    message.tempo = object.tempo ?? 0;
    message.playingMode = (object.playingMode !== undefined && object.playingMode !== null)
      ? PlayingMode.fromPartial(object.playingMode)
      : undefined;
    message.syncMode = (object.syncMode !== undefined && object.syncMode !== null)
      ? SyncMode.fromPartial(object.syncMode)
      : undefined;
    message.timeSignature = (object.timeSignature !== undefined && object.timeSignature !== null)
      ? TimeSignature.fromPartial(object.timeSignature)
      : undefined;
    message.clipDetectionInput = object.clipDetectionInput ?? false;
    message.clipDetectionOutput = object.clipDetectionOutput ?? false;
    message.masterLimiter = object.masterLimiter ?? false;
    message.usedAudioInputs = object.usedAudioInputs ?? 0;
    message.usedAudioOutputs = object.usedAudioOutputs ?? 0;
    message.inputConnections = object.inputConnections?.map((e) => TrackAudioConnectionState.fromPartial(e)) || [];
    message.outputConnections = object.outputConnections?.map((e) => TrackAudioConnectionState.fromPartial(e)) || [];
    return message;
  },
};

function createBasePluginClass(): PluginClass {
  return { name: "", label: "", uid: "", path: "", type: undefined, state: undefined };
}

export const PluginClass: MessageFns<PluginClass> = {
  encode(message: PluginClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.type !== undefined) {
      PluginType.encode(message.type, writer.uint32(42).fork()).join();
    }
    if (message.state !== undefined) {
      ProcessorState.encode(message.state, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = PluginType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.state = ProcessorState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginClass {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      type: isSet(object.type) ? PluginType.fromJSON(object.type) : undefined,
      state: isSet(object.state) ? ProcessorState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: PluginClass): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.type !== undefined) {
      obj.type = PluginType.toJSON(message.type);
    }
    if (message.state !== undefined) {
      obj.state = ProcessorState.toJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginClass>, I>>(base?: I): PluginClass {
    return PluginClass.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginClass>, I>>(object: I): PluginClass {
    const message = createBasePluginClass();
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.uid = object.uid ?? "";
    message.path = object.path ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? PluginType.fromPartial(object.type)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? ProcessorState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseTrackState(): TrackState {
  return { name: "", label: "", channels: 0, buses: 0, type: undefined, trackState: undefined, processors: [] };
}

export const TrackState: MessageFns<TrackState> = {
  encode(message: TrackState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.channels !== 0) {
      writer.uint32(24).int32(message.channels);
    }
    if (message.buses !== 0) {
      writer.uint32(32).int32(message.buses);
    }
    if (message.type !== undefined) {
      TrackType.encode(message.type, writer.uint32(42).fork()).join();
    }
    if (message.trackState !== undefined) {
      ProcessorState.encode(message.trackState, writer.uint32(50).fork()).join();
    }
    for (const v of message.processors) {
      PluginClass.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channels = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.buses = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = TrackType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trackState = ProcessorState.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.processors.push(PluginClass.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackState {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
      buses: isSet(object.buses) ? globalThis.Number(object.buses) : 0,
      type: isSet(object.type) ? TrackType.fromJSON(object.type) : undefined,
      trackState: isSet(object.trackState) ? ProcessorState.fromJSON(object.trackState) : undefined,
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => PluginClass.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TrackState): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    if (message.buses !== 0) {
      obj.buses = Math.round(message.buses);
    }
    if (message.type !== undefined) {
      obj.type = TrackType.toJSON(message.type);
    }
    if (message.trackState !== undefined) {
      obj.trackState = ProcessorState.toJSON(message.trackState);
    }
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => PluginClass.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackState>, I>>(base?: I): TrackState {
    return TrackState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackState>, I>>(object: I): TrackState {
    const message = createBaseTrackState();
    message.name = object.name ?? "";
    message.label = object.label ?? "";
    message.channels = object.channels ?? 0;
    message.buses = object.buses ?? 0;
    message.type = (object.type !== undefined && object.type !== null) ? TrackType.fromPartial(object.type) : undefined;
    message.trackState = (object.trackState !== undefined && object.trackState !== null)
      ? ProcessorState.fromPartial(object.trackState)
      : undefined;
    message.processors = object.processors?.map((e) => PluginClass.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionState(): SessionState {
  return {
    sushiInfo: undefined,
    saveDate: "",
    oscState: undefined,
    midiState: undefined,
    engineState: undefined,
    tracks: [],
  };
}

export const SessionState: MessageFns<SessionState> = {
  encode(message: SessionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sushiInfo !== undefined) {
      SushiBuildInfo.encode(message.sushiInfo, writer.uint32(10).fork()).join();
    }
    if (message.saveDate !== "") {
      writer.uint32(18).string(message.saveDate);
    }
    if (message.oscState !== undefined) {
      OscState.encode(message.oscState, writer.uint32(26).fork()).join();
    }
    if (message.midiState !== undefined) {
      MidiState.encode(message.midiState, writer.uint32(34).fork()).join();
    }
    if (message.engineState !== undefined) {
      EngineState.encode(message.engineState, writer.uint32(42).fork()).join();
    }
    for (const v of message.tracks) {
      TrackState.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sushiInfo = SushiBuildInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.saveDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oscState = OscState.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.midiState = MidiState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.engineState = EngineState.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tracks.push(TrackState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionState {
    return {
      sushiInfo: isSet(object.sushiInfo) ? SushiBuildInfo.fromJSON(object.sushiInfo) : undefined,
      saveDate: isSet(object.saveDate) ? globalThis.String(object.saveDate) : "",
      oscState: isSet(object.oscState) ? OscState.fromJSON(object.oscState) : undefined,
      midiState: isSet(object.midiState) ? MidiState.fromJSON(object.midiState) : undefined,
      engineState: isSet(object.engineState) ? EngineState.fromJSON(object.engineState) : undefined,
      tracks: globalThis.Array.isArray(object?.tracks) ? object.tracks.map((e: any) => TrackState.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionState): unknown {
    const obj: any = {};
    if (message.sushiInfo !== undefined) {
      obj.sushiInfo = SushiBuildInfo.toJSON(message.sushiInfo);
    }
    if (message.saveDate !== "") {
      obj.saveDate = message.saveDate;
    }
    if (message.oscState !== undefined) {
      obj.oscState = OscState.toJSON(message.oscState);
    }
    if (message.midiState !== undefined) {
      obj.midiState = MidiState.toJSON(message.midiState);
    }
    if (message.engineState !== undefined) {
      obj.engineState = EngineState.toJSON(message.engineState);
    }
    if (message.tracks?.length) {
      obj.tracks = message.tracks.map((e) => TrackState.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionState>, I>>(base?: I): SessionState {
    return SessionState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionState>, I>>(object: I): SessionState {
    const message = createBaseSessionState();
    message.sushiInfo = (object.sushiInfo !== undefined && object.sushiInfo !== null)
      ? SushiBuildInfo.fromPartial(object.sushiInfo)
      : undefined;
    message.saveDate = object.saveDate ?? "";
    message.oscState = (object.oscState !== undefined && object.oscState !== null)
      ? OscState.fromPartial(object.oscState)
      : undefined;
    message.midiState = (object.midiState !== undefined && object.midiState !== null)
      ? MidiState.fromPartial(object.midiState)
      : undefined;
    message.engineState = (object.engineState !== undefined && object.engineState !== null)
      ? EngineState.fromPartial(object.engineState)
      : undefined;
    message.tracks = object.tracks?.map((e) => TrackState.fromPartial(e)) || [];
    return message;
  },
};

export interface SystemController {
  GetSushiVersion(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericStringValue>;
  GetBuildInfo(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<SushiBuildInfo>;
  GetInputAudioChannelCount(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue>;
  GetOutputAudioChannelCount(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<GenericIntValue>;
}

export class SystemControllerClientImpl implements SystemController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetSushiVersion = this.GetSushiVersion.bind(this);
    this.GetBuildInfo = this.GetBuildInfo.bind(this);
    this.GetInputAudioChannelCount = this.GetInputAudioChannelCount.bind(this);
    this.GetOutputAudioChannelCount = this.GetOutputAudioChannelCount.bind(this);
  }

  GetSushiVersion(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericStringValue> {
    return this.rpc.unary(SystemControllerGetSushiVersionDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetBuildInfo(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<SushiBuildInfo> {
    return this.rpc.unary(SystemControllerGetBuildInfoDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetInputAudioChannelCount(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<GenericIntValue> {
    return this.rpc.unary(
      SystemControllerGetInputAudioChannelCountDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetOutputAudioChannelCount(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<GenericIntValue> {
    return this.rpc.unary(
      SystemControllerGetOutputAudioChannelCountDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }
}

export const SystemControllerDesc = { serviceName: "sushi_rpc.SystemController" };

export const SystemControllerGetSushiVersionDesc: UnaryMethodDefinitionish = {
  methodName: "GetSushiVersion",
  service: SystemControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericStringValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SystemControllerGetBuildInfoDesc: UnaryMethodDefinitionish = {
  methodName: "GetBuildInfo",
  service: SystemControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SushiBuildInfo.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SystemControllerGetInputAudioChannelCountDesc: UnaryMethodDefinitionish = {
  methodName: "GetInputAudioChannelCount",
  service: SystemControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SystemControllerGetOutputAudioChannelCountDesc: UnaryMethodDefinitionish = {
  methodName: "GetOutputAudioChannelCount",
  service: SystemControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface TransportController {
  GetSamplerate(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericFloatValue>;
  GetPlayingMode(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<PlayingMode>;
  GetSyncMode(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<SyncMode>;
  GetTimeSignature(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<TimeSignature>;
  GetTempo(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericFloatValue>;
  SetTempo(request: DeepPartial<GenericFloatValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SetPlayingMode(request: DeepPartial<PlayingMode>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SetSyncMode(request: DeepPartial<SyncMode>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SetTimeSignature(request: DeepPartial<TimeSignature>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
}

export class TransportControllerClientImpl implements TransportController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetSamplerate = this.GetSamplerate.bind(this);
    this.GetPlayingMode = this.GetPlayingMode.bind(this);
    this.GetSyncMode = this.GetSyncMode.bind(this);
    this.GetTimeSignature = this.GetTimeSignature.bind(this);
    this.GetTempo = this.GetTempo.bind(this);
    this.SetTempo = this.SetTempo.bind(this);
    this.SetPlayingMode = this.SetPlayingMode.bind(this);
    this.SetSyncMode = this.SetSyncMode.bind(this);
    this.SetTimeSignature = this.SetTimeSignature.bind(this);
  }

  GetSamplerate(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericFloatValue> {
    return this.rpc.unary(TransportControllerGetSamplerateDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetPlayingMode(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<PlayingMode> {
    return this.rpc.unary(TransportControllerGetPlayingModeDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetSyncMode(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<SyncMode> {
    return this.rpc.unary(TransportControllerGetSyncModeDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetTimeSignature(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<TimeSignature> {
    return this.rpc.unary(TransportControllerGetTimeSignatureDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetTempo(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericFloatValue> {
    return this.rpc.unary(TransportControllerGetTempoDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  SetTempo(request: DeepPartial<GenericFloatValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(TransportControllerSetTempoDesc, GenericFloatValue.fromPartial(request), metadata);
  }

  SetPlayingMode(request: DeepPartial<PlayingMode>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(TransportControllerSetPlayingModeDesc, PlayingMode.fromPartial(request), metadata);
  }

  SetSyncMode(request: DeepPartial<SyncMode>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(TransportControllerSetSyncModeDesc, SyncMode.fromPartial(request), metadata);
  }

  SetTimeSignature(request: DeepPartial<TimeSignature>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(TransportControllerSetTimeSignatureDesc, TimeSignature.fromPartial(request), metadata);
  }
}

export const TransportControllerDesc = { serviceName: "sushi_rpc.TransportController" };

export const TransportControllerGetSamplerateDesc: UnaryMethodDefinitionish = {
  methodName: "GetSamplerate",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericFloatValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerGetPlayingModeDesc: UnaryMethodDefinitionish = {
  methodName: "GetPlayingMode",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PlayingMode.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerGetSyncModeDesc: UnaryMethodDefinitionish = {
  methodName: "GetSyncMode",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SyncMode.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerGetTimeSignatureDesc: UnaryMethodDefinitionish = {
  methodName: "GetTimeSignature",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TimeSignature.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerGetTempoDesc: UnaryMethodDefinitionish = {
  methodName: "GetTempo",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericFloatValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerSetTempoDesc: UnaryMethodDefinitionish = {
  methodName: "SetTempo",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericFloatValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerSetPlayingModeDesc: UnaryMethodDefinitionish = {
  methodName: "SetPlayingMode",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PlayingMode.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerSetSyncModeDesc: UnaryMethodDefinitionish = {
  methodName: "SetSyncMode",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SyncMode.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TransportControllerSetTimeSignatureDesc: UnaryMethodDefinitionish = {
  methodName: "SetTimeSignature",
  service: TransportControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TimeSignature.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface TimingController {
  GetTimingsEnabled(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericBoolValue>;
  SetTimingsEnabled(request: DeepPartial<GenericBoolValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  GetEngineTimings(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<CpuTimings>;
  GetTrackTimings(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<CpuTimings>;
  GetProcessorTimings(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<CpuTimings>;
  ResetAllTimings(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  ResetTrackTimings(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  ResetProcessorTimings(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
}

export class TimingControllerClientImpl implements TimingController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetTimingsEnabled = this.GetTimingsEnabled.bind(this);
    this.SetTimingsEnabled = this.SetTimingsEnabled.bind(this);
    this.GetEngineTimings = this.GetEngineTimings.bind(this);
    this.GetTrackTimings = this.GetTrackTimings.bind(this);
    this.GetProcessorTimings = this.GetProcessorTimings.bind(this);
    this.ResetAllTimings = this.ResetAllTimings.bind(this);
    this.ResetTrackTimings = this.ResetTrackTimings.bind(this);
    this.ResetProcessorTimings = this.ResetProcessorTimings.bind(this);
  }

  GetTimingsEnabled(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericBoolValue> {
    return this.rpc.unary(TimingControllerGetTimingsEnabledDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  SetTimingsEnabled(request: DeepPartial<GenericBoolValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(TimingControllerSetTimingsEnabledDesc, GenericBoolValue.fromPartial(request), metadata);
  }

  GetEngineTimings(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<CpuTimings> {
    return this.rpc.unary(TimingControllerGetEngineTimingsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetTrackTimings(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<CpuTimings> {
    return this.rpc.unary(TimingControllerGetTrackTimingsDesc, TrackIdentifier.fromPartial(request), metadata);
  }

  GetProcessorTimings(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<CpuTimings> {
    return this.rpc.unary(TimingControllerGetProcessorTimingsDesc, ProcessorIdentifier.fromPartial(request), metadata);
  }

  ResetAllTimings(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(TimingControllerResetAllTimingsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  ResetTrackTimings(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(TimingControllerResetTrackTimingsDesc, TrackIdentifier.fromPartial(request), metadata);
  }

  ResetProcessorTimings(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      TimingControllerResetProcessorTimingsDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }
}

export const TimingControllerDesc = { serviceName: "sushi_rpc.TimingController" };

export const TimingControllerGetTimingsEnabledDesc: UnaryMethodDefinitionish = {
  methodName: "GetTimingsEnabled",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericBoolValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TimingControllerSetTimingsEnabledDesc: UnaryMethodDefinitionish = {
  methodName: "SetTimingsEnabled",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericBoolValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TimingControllerGetEngineTimingsDesc: UnaryMethodDefinitionish = {
  methodName: "GetEngineTimings",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CpuTimings.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TimingControllerGetTrackTimingsDesc: UnaryMethodDefinitionish = {
  methodName: "GetTrackTimings",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CpuTimings.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TimingControllerGetProcessorTimingsDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorTimings",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CpuTimings.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TimingControllerResetAllTimingsDesc: UnaryMethodDefinitionish = {
  methodName: "ResetAllTimings",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TimingControllerResetTrackTimingsDesc: UnaryMethodDefinitionish = {
  methodName: "ResetTrackTimings",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const TimingControllerResetProcessorTimingsDesc: UnaryMethodDefinitionish = {
  methodName: "ResetProcessorTimings",
  service: TimingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface KeyboardController {
  SendNoteOn(request: DeepPartial<NoteOnRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SendNoteOff(request: DeepPartial<NoteOffRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SendNoteAftertouch(request: DeepPartial<NoteAftertouchRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SendAftertouch(request: DeepPartial<NoteModulationRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SendPitchBend(request: DeepPartial<NoteModulationRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  SendModulation(request: DeepPartial<NoteModulationRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
}

export class KeyboardControllerClientImpl implements KeyboardController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.SendNoteOn = this.SendNoteOn.bind(this);
    this.SendNoteOff = this.SendNoteOff.bind(this);
    this.SendNoteAftertouch = this.SendNoteAftertouch.bind(this);
    this.SendAftertouch = this.SendAftertouch.bind(this);
    this.SendPitchBend = this.SendPitchBend.bind(this);
    this.SendModulation = this.SendModulation.bind(this);
  }

  SendNoteOn(request: DeepPartial<NoteOnRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(KeyboardControllerSendNoteOnDesc, NoteOnRequest.fromPartial(request), metadata);
  }

  SendNoteOff(request: DeepPartial<NoteOffRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(KeyboardControllerSendNoteOffDesc, NoteOffRequest.fromPartial(request), metadata);
  }

  SendNoteAftertouch(request: DeepPartial<NoteAftertouchRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(
      KeyboardControllerSendNoteAftertouchDesc,
      NoteAftertouchRequest.fromPartial(request),
      metadata,
    );
  }

  SendAftertouch(request: DeepPartial<NoteModulationRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(KeyboardControllerSendAftertouchDesc, NoteModulationRequest.fromPartial(request), metadata);
  }

  SendPitchBend(request: DeepPartial<NoteModulationRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(KeyboardControllerSendPitchBendDesc, NoteModulationRequest.fromPartial(request), metadata);
  }

  SendModulation(request: DeepPartial<NoteModulationRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(KeyboardControllerSendModulationDesc, NoteModulationRequest.fromPartial(request), metadata);
  }
}

export const KeyboardControllerDesc = { serviceName: "sushi_rpc.KeyboardController" };

export const KeyboardControllerSendNoteOnDesc: UnaryMethodDefinitionish = {
  methodName: "SendNoteOn",
  service: KeyboardControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return NoteOnRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const KeyboardControllerSendNoteOffDesc: UnaryMethodDefinitionish = {
  methodName: "SendNoteOff",
  service: KeyboardControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return NoteOffRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const KeyboardControllerSendNoteAftertouchDesc: UnaryMethodDefinitionish = {
  methodName: "SendNoteAftertouch",
  service: KeyboardControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return NoteAftertouchRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const KeyboardControllerSendAftertouchDesc: UnaryMethodDefinitionish = {
  methodName: "SendAftertouch",
  service: KeyboardControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return NoteModulationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const KeyboardControllerSendPitchBendDesc: UnaryMethodDefinitionish = {
  methodName: "SendPitchBend",
  service: KeyboardControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return NoteModulationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const KeyboardControllerSendModulationDesc: UnaryMethodDefinitionish = {
  methodName: "SendModulation",
  service: KeyboardControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return NoteModulationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface AudioGraphController {
  GetAllProcessors(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<ProcessorInfoList>;
  GetAllTracks(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<TrackInfoList>;
  GetTrackId(request: DeepPartial<GenericStringValue>, metadata?: grpc.Metadata): Promise<TrackIdentifier>;
  GetTrackInfo(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<TrackInfo>;
  GetTrackProcessors(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<ProcessorInfoList>;
  GetProcessorId(request: DeepPartial<GenericStringValue>, metadata?: grpc.Metadata): Promise<ProcessorIdentifier>;
  GetProcessorInfo(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<ProcessorInfo>;
  GetProcessorBypassState(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericBoolValue>;
  GetProcessorState(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<ProcessorState>;
  SetProcessorBypassState(
    request: DeepPartial<ProcessorBypassStateSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  SetProcessorState(
    request: DeepPartial<ProcessorStateSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  CreateTrack(request: DeepPartial<CreateTrackRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  CreateMultibusTrack(
    request: DeepPartial<CreateMultibusTrackRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  CreatePreTrack(request: DeepPartial<CreatePreTrackRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  CreatePostTrack(request: DeepPartial<CreatePostTrackRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  CreateProcessorOnTrack(
    request: DeepPartial<CreateProcessorRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  MoveProcessorOnTrack(request: DeepPartial<MoveProcessorRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DeleteProcessorFromTrack(
    request: DeepPartial<DeleteProcessorRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DeleteTrack(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
}

export class AudioGraphControllerClientImpl implements AudioGraphController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetAllProcessors = this.GetAllProcessors.bind(this);
    this.GetAllTracks = this.GetAllTracks.bind(this);
    this.GetTrackId = this.GetTrackId.bind(this);
    this.GetTrackInfo = this.GetTrackInfo.bind(this);
    this.GetTrackProcessors = this.GetTrackProcessors.bind(this);
    this.GetProcessorId = this.GetProcessorId.bind(this);
    this.GetProcessorInfo = this.GetProcessorInfo.bind(this);
    this.GetProcessorBypassState = this.GetProcessorBypassState.bind(this);
    this.GetProcessorState = this.GetProcessorState.bind(this);
    this.SetProcessorBypassState = this.SetProcessorBypassState.bind(this);
    this.SetProcessorState = this.SetProcessorState.bind(this);
    this.CreateTrack = this.CreateTrack.bind(this);
    this.CreateMultibusTrack = this.CreateMultibusTrack.bind(this);
    this.CreatePreTrack = this.CreatePreTrack.bind(this);
    this.CreatePostTrack = this.CreatePostTrack.bind(this);
    this.CreateProcessorOnTrack = this.CreateProcessorOnTrack.bind(this);
    this.MoveProcessorOnTrack = this.MoveProcessorOnTrack.bind(this);
    this.DeleteProcessorFromTrack = this.DeleteProcessorFromTrack.bind(this);
    this.DeleteTrack = this.DeleteTrack.bind(this);
  }

  GetAllProcessors(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<ProcessorInfoList> {
    return this.rpc.unary(AudioGraphControllerGetAllProcessorsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetAllTracks(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<TrackInfoList> {
    return this.rpc.unary(AudioGraphControllerGetAllTracksDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetTrackId(request: DeepPartial<GenericStringValue>, metadata?: grpc.Metadata): Promise<TrackIdentifier> {
    return this.rpc.unary(AudioGraphControllerGetTrackIdDesc, GenericStringValue.fromPartial(request), metadata);
  }

  GetTrackInfo(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<TrackInfo> {
    return this.rpc.unary(AudioGraphControllerGetTrackInfoDesc, TrackIdentifier.fromPartial(request), metadata);
  }

  GetTrackProcessors(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<ProcessorInfoList> {
    return this.rpc.unary(AudioGraphControllerGetTrackProcessorsDesc, TrackIdentifier.fromPartial(request), metadata);
  }

  GetProcessorId(request: DeepPartial<GenericStringValue>, metadata?: grpc.Metadata): Promise<ProcessorIdentifier> {
    return this.rpc.unary(AudioGraphControllerGetProcessorIdDesc, GenericStringValue.fromPartial(request), metadata);
  }

  GetProcessorInfo(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<ProcessorInfo> {
    return this.rpc.unary(AudioGraphControllerGetProcessorInfoDesc, ProcessorIdentifier.fromPartial(request), metadata);
  }

  GetProcessorBypassState(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericBoolValue> {
    return this.rpc.unary(
      AudioGraphControllerGetProcessorBypassStateDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetProcessorState(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<ProcessorState> {
    return this.rpc.unary(
      AudioGraphControllerGetProcessorStateDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  SetProcessorBypassState(
    request: DeepPartial<ProcessorBypassStateSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioGraphControllerSetProcessorBypassStateDesc,
      ProcessorBypassStateSetRequest.fromPartial(request),
      metadata,
    );
  }

  SetProcessorState(
    request: DeepPartial<ProcessorStateSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioGraphControllerSetProcessorStateDesc,
      ProcessorStateSetRequest.fromPartial(request),
      metadata,
    );
  }

  CreateTrack(request: DeepPartial<CreateTrackRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(AudioGraphControllerCreateTrackDesc, CreateTrackRequest.fromPartial(request), metadata);
  }

  CreateMultibusTrack(
    request: DeepPartial<CreateMultibusTrackRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioGraphControllerCreateMultibusTrackDesc,
      CreateMultibusTrackRequest.fromPartial(request),
      metadata,
    );
  }

  CreatePreTrack(request: DeepPartial<CreatePreTrackRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(AudioGraphControllerCreatePreTrackDesc, CreatePreTrackRequest.fromPartial(request), metadata);
  }

  CreatePostTrack(request: DeepPartial<CreatePostTrackRequest>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioGraphControllerCreatePostTrackDesc,
      CreatePostTrackRequest.fromPartial(request),
      metadata,
    );
  }

  CreateProcessorOnTrack(
    request: DeepPartial<CreateProcessorRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioGraphControllerCreateProcessorOnTrackDesc,
      CreateProcessorRequest.fromPartial(request),
      metadata,
    );
  }

  MoveProcessorOnTrack(
    request: DeepPartial<MoveProcessorRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioGraphControllerMoveProcessorOnTrackDesc,
      MoveProcessorRequest.fromPartial(request),
      metadata,
    );
  }

  DeleteProcessorFromTrack(
    request: DeepPartial<DeleteProcessorRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioGraphControllerDeleteProcessorFromTrackDesc,
      DeleteProcessorRequest.fromPartial(request),
      metadata,
    );
  }

  DeleteTrack(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(AudioGraphControllerDeleteTrackDesc, TrackIdentifier.fromPartial(request), metadata);
  }
}

export const AudioGraphControllerDesc = { serviceName: "sushi_rpc.AudioGraphController" };

export const AudioGraphControllerGetAllProcessorsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllProcessors",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProcessorInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetAllTracksDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllTracks",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TrackInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetTrackIdDesc: UnaryMethodDefinitionish = {
  methodName: "GetTrackId",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericStringValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TrackIdentifier.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetTrackInfoDesc: UnaryMethodDefinitionish = {
  methodName: "GetTrackInfo",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TrackInfo.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetTrackProcessorsDesc: UnaryMethodDefinitionish = {
  methodName: "GetTrackProcessors",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProcessorInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetProcessorIdDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorId",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericStringValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProcessorIdentifier.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetProcessorInfoDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorInfo",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProcessorInfo.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetProcessorBypassStateDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorBypassState",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericBoolValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerGetProcessorStateDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorState",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProcessorState.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerSetProcessorBypassStateDesc: UnaryMethodDefinitionish = {
  methodName: "SetProcessorBypassState",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorBypassStateSetRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerSetProcessorStateDesc: UnaryMethodDefinitionish = {
  methodName: "SetProcessorState",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorStateSetRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerCreateTrackDesc: UnaryMethodDefinitionish = {
  methodName: "CreateTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateTrackRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerCreateMultibusTrackDesc: UnaryMethodDefinitionish = {
  methodName: "CreateMultibusTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateMultibusTrackRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerCreatePreTrackDesc: UnaryMethodDefinitionish = {
  methodName: "CreatePreTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreatePreTrackRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerCreatePostTrackDesc: UnaryMethodDefinitionish = {
  methodName: "CreatePostTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreatePostTrackRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerCreateProcessorOnTrackDesc: UnaryMethodDefinitionish = {
  methodName: "CreateProcessorOnTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateProcessorRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerMoveProcessorOnTrackDesc: UnaryMethodDefinitionish = {
  methodName: "MoveProcessorOnTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MoveProcessorRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerDeleteProcessorFromTrackDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteProcessorFromTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteProcessorRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioGraphControllerDeleteTrackDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteTrack",
  service: AudioGraphControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface ProgramController {
  GetProcessorCurrentProgram(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<ProgramIdentifier>;
  GetProcessorCurrentProgramName(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericStringValue>;
  GetProcessorProgramName(
    request: DeepPartial<ProcessorProgramIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericStringValue>;
  GetProcessorPrograms(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<ProgramInfoList>;
  SetProcessorProgram(
    request: DeepPartial<ProcessorProgramSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
}

export class ProgramControllerClientImpl implements ProgramController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetProcessorCurrentProgram = this.GetProcessorCurrentProgram.bind(this);
    this.GetProcessorCurrentProgramName = this.GetProcessorCurrentProgramName.bind(this);
    this.GetProcessorProgramName = this.GetProcessorProgramName.bind(this);
    this.GetProcessorPrograms = this.GetProcessorPrograms.bind(this);
    this.SetProcessorProgram = this.SetProcessorProgram.bind(this);
  }

  GetProcessorCurrentProgram(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<ProgramIdentifier> {
    return this.rpc.unary(
      ProgramControllerGetProcessorCurrentProgramDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetProcessorCurrentProgramName(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericStringValue> {
    return this.rpc.unary(
      ProgramControllerGetProcessorCurrentProgramNameDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetProcessorProgramName(
    request: DeepPartial<ProcessorProgramIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericStringValue> {
    return this.rpc.unary(
      ProgramControllerGetProcessorProgramNameDesc,
      ProcessorProgramIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetProcessorPrograms(request: DeepPartial<ProcessorIdentifier>, metadata?: grpc.Metadata): Promise<ProgramInfoList> {
    return this.rpc.unary(
      ProgramControllerGetProcessorProgramsDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  SetProcessorProgram(
    request: DeepPartial<ProcessorProgramSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      ProgramControllerSetProcessorProgramDesc,
      ProcessorProgramSetRequest.fromPartial(request),
      metadata,
    );
  }
}

export const ProgramControllerDesc = { serviceName: "sushi_rpc.ProgramController" };

export const ProgramControllerGetProcessorCurrentProgramDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorCurrentProgram",
  service: ProgramControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProgramIdentifier.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramControllerGetProcessorCurrentProgramNameDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorCurrentProgramName",
  service: ProgramControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericStringValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramControllerGetProcessorProgramNameDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorProgramName",
  service: ProgramControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorProgramIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericStringValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramControllerGetProcessorProgramsDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorPrograms",
  service: ProgramControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProgramInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ProgramControllerSetProcessorProgramDesc: UnaryMethodDefinitionish = {
  methodName: "SetProcessorProgram",
  service: ProgramControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorProgramSetRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface ParameterController {
  GetTrackParameters(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<ParameterInfoList>;
  GetProcessorParameters(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<ParameterInfoList>;
  GetParameterId(request: DeepPartial<ParameterIdRequest>, metadata?: grpc.Metadata): Promise<ParameterIdentifier>;
  GetParameterInfo(request: DeepPartial<ParameterIdentifier>, metadata?: grpc.Metadata): Promise<ParameterInfo>;
  GetParameterValue(request: DeepPartial<ParameterIdentifier>, metadata?: grpc.Metadata): Promise<GenericFloatValue>;
  GetParameterValueInDomain(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericFloatValue>;
  GetParameterValueAsString(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericStringValue>;
  SetParameterValue(request: DeepPartial<ParameterValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  GetTrackProperties(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<PropertyInfoList>;
  GetProcessorProperties(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<PropertyInfoList>;
  GetPropertyId(request: DeepPartial<PropertyIdRequest>, metadata?: grpc.Metadata): Promise<PropertyIdentifier>;
  GetPropertyInfo(request: DeepPartial<PropertyIdentifier>, metadata?: grpc.Metadata): Promise<PropertyInfo>;
  GetPropertyValue(request: DeepPartial<PropertyIdentifier>, metadata?: grpc.Metadata): Promise<GenericStringValue>;
  SetPropertyValue(request: DeepPartial<PropertyValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
}

export class ParameterControllerClientImpl implements ParameterController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetTrackParameters = this.GetTrackParameters.bind(this);
    this.GetProcessorParameters = this.GetProcessorParameters.bind(this);
    this.GetParameterId = this.GetParameterId.bind(this);
    this.GetParameterInfo = this.GetParameterInfo.bind(this);
    this.GetParameterValue = this.GetParameterValue.bind(this);
    this.GetParameterValueInDomain = this.GetParameterValueInDomain.bind(this);
    this.GetParameterValueAsString = this.GetParameterValueAsString.bind(this);
    this.SetParameterValue = this.SetParameterValue.bind(this);
    this.GetTrackProperties = this.GetTrackProperties.bind(this);
    this.GetProcessorProperties = this.GetProcessorProperties.bind(this);
    this.GetPropertyId = this.GetPropertyId.bind(this);
    this.GetPropertyInfo = this.GetPropertyInfo.bind(this);
    this.GetPropertyValue = this.GetPropertyValue.bind(this);
    this.SetPropertyValue = this.SetPropertyValue.bind(this);
  }

  GetTrackParameters(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<ParameterInfoList> {
    return this.rpc.unary(ParameterControllerGetTrackParametersDesc, TrackIdentifier.fromPartial(request), metadata);
  }

  GetProcessorParameters(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<ParameterInfoList> {
    return this.rpc.unary(
      ParameterControllerGetProcessorParametersDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetParameterId(request: DeepPartial<ParameterIdRequest>, metadata?: grpc.Metadata): Promise<ParameterIdentifier> {
    return this.rpc.unary(ParameterControllerGetParameterIdDesc, ParameterIdRequest.fromPartial(request), metadata);
  }

  GetParameterInfo(request: DeepPartial<ParameterIdentifier>, metadata?: grpc.Metadata): Promise<ParameterInfo> {
    return this.rpc.unary(ParameterControllerGetParameterInfoDesc, ParameterIdentifier.fromPartial(request), metadata);
  }

  GetParameterValue(request: DeepPartial<ParameterIdentifier>, metadata?: grpc.Metadata): Promise<GenericFloatValue> {
    return this.rpc.unary(ParameterControllerGetParameterValueDesc, ParameterIdentifier.fromPartial(request), metadata);
  }

  GetParameterValueInDomain(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericFloatValue> {
    return this.rpc.unary(
      ParameterControllerGetParameterValueInDomainDesc,
      ParameterIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetParameterValueAsString(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericStringValue> {
    return this.rpc.unary(
      ParameterControllerGetParameterValueAsStringDesc,
      ParameterIdentifier.fromPartial(request),
      metadata,
    );
  }

  SetParameterValue(request: DeepPartial<ParameterValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(ParameterControllerSetParameterValueDesc, ParameterValue.fromPartial(request), metadata);
  }

  GetTrackProperties(request: DeepPartial<TrackIdentifier>, metadata?: grpc.Metadata): Promise<PropertyInfoList> {
    return this.rpc.unary(ParameterControllerGetTrackPropertiesDesc, TrackIdentifier.fromPartial(request), metadata);
  }

  GetProcessorProperties(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<PropertyInfoList> {
    return this.rpc.unary(
      ParameterControllerGetProcessorPropertiesDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetPropertyId(request: DeepPartial<PropertyIdRequest>, metadata?: grpc.Metadata): Promise<PropertyIdentifier> {
    return this.rpc.unary(ParameterControllerGetPropertyIdDesc, PropertyIdRequest.fromPartial(request), metadata);
  }

  GetPropertyInfo(request: DeepPartial<PropertyIdentifier>, metadata?: grpc.Metadata): Promise<PropertyInfo> {
    return this.rpc.unary(ParameterControllerGetPropertyInfoDesc, PropertyIdentifier.fromPartial(request), metadata);
  }

  GetPropertyValue(request: DeepPartial<PropertyIdentifier>, metadata?: grpc.Metadata): Promise<GenericStringValue> {
    return this.rpc.unary(ParameterControllerGetPropertyValueDesc, PropertyIdentifier.fromPartial(request), metadata);
  }

  SetPropertyValue(request: DeepPartial<PropertyValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(ParameterControllerSetPropertyValueDesc, PropertyValue.fromPartial(request), metadata);
  }
}

export const ParameterControllerDesc = { serviceName: "sushi_rpc.ParameterController" };

export const ParameterControllerGetTrackParametersDesc: UnaryMethodDefinitionish = {
  methodName: "GetTrackParameters",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ParameterInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetProcessorParametersDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorParameters",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ParameterInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetParameterIdDesc: UnaryMethodDefinitionish = {
  methodName: "GetParameterId",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterIdRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ParameterIdentifier.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetParameterInfoDesc: UnaryMethodDefinitionish = {
  methodName: "GetParameterInfo",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ParameterInfo.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetParameterValueDesc: UnaryMethodDefinitionish = {
  methodName: "GetParameterValue",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericFloatValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetParameterValueInDomainDesc: UnaryMethodDefinitionish = {
  methodName: "GetParameterValueInDomain",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericFloatValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetParameterValueAsStringDesc: UnaryMethodDefinitionish = {
  methodName: "GetParameterValueAsString",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericStringValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerSetParameterValueDesc: UnaryMethodDefinitionish = {
  methodName: "SetParameterValue",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetTrackPropertiesDesc: UnaryMethodDefinitionish = {
  methodName: "GetTrackProperties",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PropertyInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetProcessorPropertiesDesc: UnaryMethodDefinitionish = {
  methodName: "GetProcessorProperties",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PropertyInfoList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetPropertyIdDesc: UnaryMethodDefinitionish = {
  methodName: "GetPropertyId",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PropertyIdRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PropertyIdentifier.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetPropertyInfoDesc: UnaryMethodDefinitionish = {
  methodName: "GetPropertyInfo",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PropertyIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PropertyInfo.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerGetPropertyValueDesc: UnaryMethodDefinitionish = {
  methodName: "GetPropertyValue",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PropertyIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericStringValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ParameterControllerSetPropertyValueDesc: UnaryMethodDefinitionish = {
  methodName: "SetPropertyValue",
  service: ParameterControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PropertyValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface MidiController {
  GetInputPorts(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue>;
  GetOutputPorts(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue>;
  GetAllKbdInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiKbdConnectionList>;
  GetAllKbdOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiKbdConnectionList>;
  GetAllCCInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiCCConnectionList>;
  GetAllPCInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiPCConnectionList>;
  GetCCInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<MidiCCConnectionList>;
  GetPCInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<MidiPCConnectionList>;
  GetMidiClockOutputEnabled(request: DeepPartial<GenericIntValue>, metadata?: grpc.Metadata): Promise<GenericBoolValue>;
  SetMidiClockOutputEnabled(
    request: DeepPartial<MidiClockSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  ConnectKbdInputToTrack(request: DeepPartial<MidiKbdConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  ConnectKbdOutputFromTrack(
    request: DeepPartial<MidiKbdConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  ConnectCCToParameter(request: DeepPartial<MidiCCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  ConnectPCToProcessor(request: DeepPartial<MidiPCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectKbdInput(request: DeepPartial<MidiKbdConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectKbdOutput(request: DeepPartial<MidiKbdConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectCC(request: DeepPartial<MidiCCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectPC(request: DeepPartial<MidiPCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectAllCCFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisconnectAllPCFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
}

export class MidiControllerClientImpl implements MidiController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetInputPorts = this.GetInputPorts.bind(this);
    this.GetOutputPorts = this.GetOutputPorts.bind(this);
    this.GetAllKbdInputConnections = this.GetAllKbdInputConnections.bind(this);
    this.GetAllKbdOutputConnections = this.GetAllKbdOutputConnections.bind(this);
    this.GetAllCCInputConnections = this.GetAllCCInputConnections.bind(this);
    this.GetAllPCInputConnections = this.GetAllPCInputConnections.bind(this);
    this.GetCCInputConnectionsForProcessor = this.GetCCInputConnectionsForProcessor.bind(this);
    this.GetPCInputConnectionsForProcessor = this.GetPCInputConnectionsForProcessor.bind(this);
    this.GetMidiClockOutputEnabled = this.GetMidiClockOutputEnabled.bind(this);
    this.SetMidiClockOutputEnabled = this.SetMidiClockOutputEnabled.bind(this);
    this.ConnectKbdInputToTrack = this.ConnectKbdInputToTrack.bind(this);
    this.ConnectKbdOutputFromTrack = this.ConnectKbdOutputFromTrack.bind(this);
    this.ConnectCCToParameter = this.ConnectCCToParameter.bind(this);
    this.ConnectPCToProcessor = this.ConnectPCToProcessor.bind(this);
    this.DisconnectKbdInput = this.DisconnectKbdInput.bind(this);
    this.DisconnectKbdOutput = this.DisconnectKbdOutput.bind(this);
    this.DisconnectCC = this.DisconnectCC.bind(this);
    this.DisconnectPC = this.DisconnectPC.bind(this);
    this.DisconnectAllCCFromProcessor = this.DisconnectAllCCFromProcessor.bind(this);
    this.DisconnectAllPCFromProcessor = this.DisconnectAllPCFromProcessor.bind(this);
  }

  GetInputPorts(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue> {
    return this.rpc.unary(MidiControllerGetInputPortsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetOutputPorts(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue> {
    return this.rpc.unary(MidiControllerGetOutputPortsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetAllKbdInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiKbdConnectionList> {
    return this.rpc.unary(MidiControllerGetAllKbdInputConnectionsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetAllKbdOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiKbdConnectionList> {
    return this.rpc.unary(
      MidiControllerGetAllKbdOutputConnectionsDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetAllCCInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiCCConnectionList> {
    return this.rpc.unary(MidiControllerGetAllCCInputConnectionsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetAllPCInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<MidiPCConnectionList> {
    return this.rpc.unary(MidiControllerGetAllPCInputConnectionsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetCCInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<MidiCCConnectionList> {
    return this.rpc.unary(
      MidiControllerGetCCInputConnectionsForProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetPCInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<MidiPCConnectionList> {
    return this.rpc.unary(
      MidiControllerGetPCInputConnectionsForProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetMidiClockOutputEnabled(
    request: DeepPartial<GenericIntValue>,
    metadata?: grpc.Metadata,
  ): Promise<GenericBoolValue> {
    return this.rpc.unary(MidiControllerGetMidiClockOutputEnabledDesc, GenericIntValue.fromPartial(request), metadata);
  }

  SetMidiClockOutputEnabled(
    request: DeepPartial<MidiClockSetRequest>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      MidiControllerSetMidiClockOutputEnabledDesc,
      MidiClockSetRequest.fromPartial(request),
      metadata,
    );
  }

  ConnectKbdInputToTrack(request: DeepPartial<MidiKbdConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(MidiControllerConnectKbdInputToTrackDesc, MidiKbdConnection.fromPartial(request), metadata);
  }

  ConnectKbdOutputFromTrack(
    request: DeepPartial<MidiKbdConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      MidiControllerConnectKbdOutputFromTrackDesc,
      MidiKbdConnection.fromPartial(request),
      metadata,
    );
  }

  ConnectCCToParameter(request: DeepPartial<MidiCCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(MidiControllerConnectCCToParameterDesc, MidiCCConnection.fromPartial(request), metadata);
  }

  ConnectPCToProcessor(request: DeepPartial<MidiPCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(MidiControllerConnectPCToProcessorDesc, MidiPCConnection.fromPartial(request), metadata);
  }

  DisconnectKbdInput(request: DeepPartial<MidiKbdConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(MidiControllerDisconnectKbdInputDesc, MidiKbdConnection.fromPartial(request), metadata);
  }

  DisconnectKbdOutput(request: DeepPartial<MidiKbdConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(MidiControllerDisconnectKbdOutputDesc, MidiKbdConnection.fromPartial(request), metadata);
  }

  DisconnectCC(request: DeepPartial<MidiCCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(MidiControllerDisconnectCCDesc, MidiCCConnection.fromPartial(request), metadata);
  }

  DisconnectPC(request: DeepPartial<MidiPCConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(MidiControllerDisconnectPCDesc, MidiPCConnection.fromPartial(request), metadata);
  }

  DisconnectAllCCFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      MidiControllerDisconnectAllCCFromProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  DisconnectAllPCFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      MidiControllerDisconnectAllPCFromProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }
}

export const MidiControllerDesc = { serviceName: "sushi_rpc.MidiController" };

export const MidiControllerGetInputPortsDesc: UnaryMethodDefinitionish = {
  methodName: "GetInputPorts",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetOutputPortsDesc: UnaryMethodDefinitionish = {
  methodName: "GetOutputPorts",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetAllKbdInputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllKbdInputConnections",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MidiKbdConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetAllKbdOutputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllKbdOutputConnections",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MidiKbdConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetAllCCInputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllCCInputConnections",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MidiCCConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetAllPCInputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllPCInputConnections",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MidiPCConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetCCInputConnectionsForProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "GetCCInputConnectionsForProcessor",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MidiCCConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetPCInputConnectionsForProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "GetPCInputConnectionsForProcessor",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MidiPCConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerGetMidiClockOutputEnabledDesc: UnaryMethodDefinitionish = {
  methodName: "GetMidiClockOutputEnabled",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericIntValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericBoolValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerSetMidiClockOutputEnabledDesc: UnaryMethodDefinitionish = {
  methodName: "SetMidiClockOutputEnabled",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiClockSetRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerConnectKbdInputToTrackDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectKbdInputToTrack",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiKbdConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerConnectKbdOutputFromTrackDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectKbdOutputFromTrack",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiKbdConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerConnectCCToParameterDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectCCToParameter",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiCCConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerConnectPCToProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectPCToProcessor",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiPCConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerDisconnectKbdInputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectKbdInput",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiKbdConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerDisconnectKbdOutputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectKbdOutput",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiKbdConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerDisconnectCCDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectCC",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiCCConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerDisconnectPCDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectPC",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MidiPCConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerDisconnectAllCCFromProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllCCFromProcessor",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MidiControllerDisconnectAllPCFromProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllPCFromProcessor",
  service: MidiControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface AudioRoutingController {
  GetAllInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList>;
  GetAllOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList>;
  GetInputConnectionsForTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList>;
  GetOutputConnectionsForTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList>;
  ConnectInputChannelToTrack(
    request: DeepPartial<AudioConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  ConnectOutputChannelFromTrack(
    request: DeepPartial<AudioConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisconnectInput(request: DeepPartial<AudioConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectOutput(request: DeepPartial<AudioConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectAllInputsFromTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  /** @deprecated */
  DisconnectAllOutputFromTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisconnectAllOutputsFromTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
}

export class AudioRoutingControllerClientImpl implements AudioRoutingController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetAllInputConnections = this.GetAllInputConnections.bind(this);
    this.GetAllOutputConnections = this.GetAllOutputConnections.bind(this);
    this.GetInputConnectionsForTrack = this.GetInputConnectionsForTrack.bind(this);
    this.GetOutputConnectionsForTrack = this.GetOutputConnectionsForTrack.bind(this);
    this.ConnectInputChannelToTrack = this.ConnectInputChannelToTrack.bind(this);
    this.ConnectOutputChannelFromTrack = this.ConnectOutputChannelFromTrack.bind(this);
    this.DisconnectInput = this.DisconnectInput.bind(this);
    this.DisconnectOutput = this.DisconnectOutput.bind(this);
    this.DisconnectAllInputsFromTrack = this.DisconnectAllInputsFromTrack.bind(this);
    this.DisconnectAllOutputFromTrack = this.DisconnectAllOutputFromTrack.bind(this);
    this.DisconnectAllOutputsFromTrack = this.DisconnectAllOutputsFromTrack.bind(this);
  }

  GetAllInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList> {
    return this.rpc.unary(
      AudioRoutingControllerGetAllInputConnectionsDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetAllOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList> {
    return this.rpc.unary(
      AudioRoutingControllerGetAllOutputConnectionsDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetInputConnectionsForTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList> {
    return this.rpc.unary(
      AudioRoutingControllerGetInputConnectionsForTrackDesc,
      TrackIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetOutputConnectionsForTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<AudioConnectionList> {
    return this.rpc.unary(
      AudioRoutingControllerGetOutputConnectionsForTrackDesc,
      TrackIdentifier.fromPartial(request),
      metadata,
    );
  }

  ConnectInputChannelToTrack(
    request: DeepPartial<AudioConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioRoutingControllerConnectInputChannelToTrackDesc,
      AudioConnection.fromPartial(request),
      metadata,
    );
  }

  ConnectOutputChannelFromTrack(
    request: DeepPartial<AudioConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioRoutingControllerConnectOutputChannelFromTrackDesc,
      AudioConnection.fromPartial(request),
      metadata,
    );
  }

  DisconnectInput(request: DeepPartial<AudioConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(AudioRoutingControllerDisconnectInputDesc, AudioConnection.fromPartial(request), metadata);
  }

  DisconnectOutput(request: DeepPartial<AudioConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(AudioRoutingControllerDisconnectOutputDesc, AudioConnection.fromPartial(request), metadata);
  }

  DisconnectAllInputsFromTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioRoutingControllerDisconnectAllInputsFromTrackDesc,
      TrackIdentifier.fromPartial(request),
      metadata,
    );
  }

  DisconnectAllOutputFromTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioRoutingControllerDisconnectAllOutputFromTrackDesc,
      TrackIdentifier.fromPartial(request),
      metadata,
    );
  }

  DisconnectAllOutputsFromTrack(
    request: DeepPartial<TrackIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      AudioRoutingControllerDisconnectAllOutputsFromTrackDesc,
      TrackIdentifier.fromPartial(request),
      metadata,
    );
  }
}

export const AudioRoutingControllerDesc = { serviceName: "sushi_rpc.AudioRoutingController" };

export const AudioRoutingControllerGetAllInputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllInputConnections",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AudioConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerGetAllOutputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllOutputConnections",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AudioConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerGetInputConnectionsForTrackDesc: UnaryMethodDefinitionish = {
  methodName: "GetInputConnectionsForTrack",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AudioConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerGetOutputConnectionsForTrackDesc: UnaryMethodDefinitionish = {
  methodName: "GetOutputConnectionsForTrack",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = AudioConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerConnectInputChannelToTrackDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectInputChannelToTrack",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AudioConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerConnectOutputChannelFromTrackDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectOutputChannelFromTrack",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AudioConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerDisconnectInputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectInput",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AudioConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerDisconnectOutputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectOutput",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AudioConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerDisconnectAllInputsFromTrackDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllInputsFromTrack",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerDisconnectAllOutputFromTrackDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllOutputFromTrack",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AudioRoutingControllerDisconnectAllOutputsFromTrackDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllOutputsFromTrack",
  service: AudioRoutingControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return TrackIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface CvGateController {
  GetCvInputChannelCount(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue>;
  GetCvOutputChannelCount(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue>;
  GetAllCvInputConnections(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<CvConnectionList>;
  GetAllCvOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<CvConnectionList>;
  GetAllGateInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList>;
  GetAllGateOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList>;
  GetCvInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<CvConnectionList>;
  GetCvOutputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<CvConnectionList>;
  GetGateInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList>;
  GetGateOutputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList>;
  ConnectCvInputToParameter(request: DeepPartial<CvConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  ConnectCvOutputFromParameter(request: DeepPartial<CvConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  ConnectGateInputToProcessor(
    request: DeepPartial<GateConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  ConnectGateOutputFromProcessor(
    request: DeepPartial<GateConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisconnectCvInput(request: DeepPartial<CvConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectCvOutput(request: DeepPartial<CvConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectGateInput(request: DeepPartial<GateConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectGateOutput(request: DeepPartial<GateConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisconnectAllCvInputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisconnectAllCvOutputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisconnectAllGateInputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisconnectAllGateOutputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
}

export class CvGateControllerClientImpl implements CvGateController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetCvInputChannelCount = this.GetCvInputChannelCount.bind(this);
    this.GetCvOutputChannelCount = this.GetCvOutputChannelCount.bind(this);
    this.GetAllCvInputConnections = this.GetAllCvInputConnections.bind(this);
    this.GetAllCvOutputConnections = this.GetAllCvOutputConnections.bind(this);
    this.GetAllGateInputConnections = this.GetAllGateInputConnections.bind(this);
    this.GetAllGateOutputConnections = this.GetAllGateOutputConnections.bind(this);
    this.GetCvInputConnectionsForProcessor = this.GetCvInputConnectionsForProcessor.bind(this);
    this.GetCvOutputConnectionsForProcessor = this.GetCvOutputConnectionsForProcessor.bind(this);
    this.GetGateInputConnectionsForProcessor = this.GetGateInputConnectionsForProcessor.bind(this);
    this.GetGateOutputConnectionsForProcessor = this.GetGateOutputConnectionsForProcessor.bind(this);
    this.ConnectCvInputToParameter = this.ConnectCvInputToParameter.bind(this);
    this.ConnectCvOutputFromParameter = this.ConnectCvOutputFromParameter.bind(this);
    this.ConnectGateInputToProcessor = this.ConnectGateInputToProcessor.bind(this);
    this.ConnectGateOutputFromProcessor = this.ConnectGateOutputFromProcessor.bind(this);
    this.DisconnectCvInput = this.DisconnectCvInput.bind(this);
    this.DisconnectCvOutput = this.DisconnectCvOutput.bind(this);
    this.DisconnectGateInput = this.DisconnectGateInput.bind(this);
    this.DisconnectGateOutput = this.DisconnectGateOutput.bind(this);
    this.DisconnectAllCvInputsFromProcessor = this.DisconnectAllCvInputsFromProcessor.bind(this);
    this.DisconnectAllCvOutputsFromProcessor = this.DisconnectAllCvOutputsFromProcessor.bind(this);
    this.DisconnectAllGateInputsFromProcessor = this.DisconnectAllGateInputsFromProcessor.bind(this);
    this.DisconnectAllGateOutputsFromProcessor = this.DisconnectAllGateOutputsFromProcessor.bind(this);
  }

  GetCvInputChannelCount(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue> {
    return this.rpc.unary(CvGateControllerGetCvInputChannelCountDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetCvOutputChannelCount(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue> {
    return this.rpc.unary(CvGateControllerGetCvOutputChannelCountDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetAllCvInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<CvConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetAllCvInputConnectionsDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetAllCvOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<CvConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetAllCvOutputConnectionsDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetAllGateInputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetAllGateInputConnectionsDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetAllGateOutputConnections(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetAllGateOutputConnectionsDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  GetCvInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<CvConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetCvInputConnectionsForProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetCvOutputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<CvConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetCvOutputConnectionsForProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetGateInputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetGateInputConnectionsForProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  GetGateOutputConnectionsForProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GateConnectionList> {
    return this.rpc.unary(
      CvGateControllerGetGateOutputConnectionsForProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  ConnectCvInputToParameter(request: DeepPartial<CvConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(CvGateControllerConnectCvInputToParameterDesc, CvConnection.fromPartial(request), metadata);
  }

  ConnectCvOutputFromParameter(
    request: DeepPartial<CvConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      CvGateControllerConnectCvOutputFromParameterDesc,
      CvConnection.fromPartial(request),
      metadata,
    );
  }

  ConnectGateInputToProcessor(
    request: DeepPartial<GateConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      CvGateControllerConnectGateInputToProcessorDesc,
      GateConnection.fromPartial(request),
      metadata,
    );
  }

  ConnectGateOutputFromProcessor(
    request: DeepPartial<GateConnection>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      CvGateControllerConnectGateOutputFromProcessorDesc,
      GateConnection.fromPartial(request),
      metadata,
    );
  }

  DisconnectCvInput(request: DeepPartial<CvConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(CvGateControllerDisconnectCvInputDesc, CvConnection.fromPartial(request), metadata);
  }

  DisconnectCvOutput(request: DeepPartial<CvConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(CvGateControllerDisconnectCvOutputDesc, CvConnection.fromPartial(request), metadata);
  }

  DisconnectGateInput(request: DeepPartial<GateConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(CvGateControllerDisconnectGateInputDesc, GateConnection.fromPartial(request), metadata);
  }

  DisconnectGateOutput(request: DeepPartial<GateConnection>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(CvGateControllerDisconnectGateOutputDesc, GateConnection.fromPartial(request), metadata);
  }

  DisconnectAllCvInputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      CvGateControllerDisconnectAllCvInputsFromProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  DisconnectAllCvOutputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      CvGateControllerDisconnectAllCvOutputsFromProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  DisconnectAllGateInputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      CvGateControllerDisconnectAllGateInputsFromProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }

  DisconnectAllGateOutputsFromProcessor(
    request: DeepPartial<ProcessorIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      CvGateControllerDisconnectAllGateOutputsFromProcessorDesc,
      ProcessorIdentifier.fromPartial(request),
      metadata,
    );
  }
}

export const CvGateControllerDesc = { serviceName: "sushi_rpc.CvGateController" };

export const CvGateControllerGetCvInputChannelCountDesc: UnaryMethodDefinitionish = {
  methodName: "GetCvInputChannelCount",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetCvOutputChannelCountDesc: UnaryMethodDefinitionish = {
  methodName: "GetCvOutputChannelCount",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetAllCvInputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllCvInputConnections",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CvConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetAllCvOutputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllCvOutputConnections",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CvConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetAllGateInputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllGateInputConnections",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GateConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetAllGateOutputConnectionsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllGateOutputConnections",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GateConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetCvInputConnectionsForProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "GetCvInputConnectionsForProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CvConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetCvOutputConnectionsForProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "GetCvOutputConnectionsForProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CvConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetGateInputConnectionsForProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "GetGateInputConnectionsForProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GateConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerGetGateOutputConnectionsForProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "GetGateOutputConnectionsForProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GateConnectionList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerConnectCvInputToParameterDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectCvInputToParameter",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CvConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerConnectCvOutputFromParameterDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectCvOutputFromParameter",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CvConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerConnectGateInputToProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectGateInputToProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GateConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerConnectGateOutputFromProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "ConnectGateOutputFromProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GateConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectCvInputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectCvInput",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CvConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectCvOutputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectCvOutput",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CvConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectGateInputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectGateInput",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GateConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectGateOutputDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectGateOutput",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GateConnection.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectAllCvInputsFromProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllCvInputsFromProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectAllCvOutputsFromProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllCvOutputsFromProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectAllGateInputsFromProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllGateInputsFromProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const CvGateControllerDisconnectAllGateOutputsFromProcessorDesc: UnaryMethodDefinitionish = {
  methodName: "DisconnectAllGateOutputsFromProcessor",
  service: CvGateControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ProcessorIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface OscController {
  GetSendIP(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericStringValue>;
  GetSendPort(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue>;
  GetReceivePort(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue>;
  GetEnabledParameterOutputs(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<OscParameterOutputList>;
  EnableOutputForParameter(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  DisableOutputForParameter(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue>;
  EnableAllOutput(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
  DisableAllOutput(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
}

export class OscControllerClientImpl implements OscController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.GetSendIP = this.GetSendIP.bind(this);
    this.GetSendPort = this.GetSendPort.bind(this);
    this.GetReceivePort = this.GetReceivePort.bind(this);
    this.GetEnabledParameterOutputs = this.GetEnabledParameterOutputs.bind(this);
    this.EnableOutputForParameter = this.EnableOutputForParameter.bind(this);
    this.DisableOutputForParameter = this.DisableOutputForParameter.bind(this);
    this.EnableAllOutput = this.EnableAllOutput.bind(this);
    this.DisableAllOutput = this.DisableAllOutput.bind(this);
  }

  GetSendIP(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericStringValue> {
    return this.rpc.unary(OscControllerGetSendIPDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetSendPort(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue> {
    return this.rpc.unary(OscControllerGetSendPortDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetReceivePort(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericIntValue> {
    return this.rpc.unary(OscControllerGetReceivePortDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  GetEnabledParameterOutputs(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Promise<OscParameterOutputList> {
    return this.rpc.unary(OscControllerGetEnabledParameterOutputsDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  EnableOutputForParameter(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      OscControllerEnableOutputForParameterDesc,
      ParameterIdentifier.fromPartial(request),
      metadata,
    );
  }

  DisableOutputForParameter(
    request: DeepPartial<ParameterIdentifier>,
    metadata?: grpc.Metadata,
  ): Promise<GenericVoidValue> {
    return this.rpc.unary(
      OscControllerDisableOutputForParameterDesc,
      ParameterIdentifier.fromPartial(request),
      metadata,
    );
  }

  EnableAllOutput(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(OscControllerEnableAllOutputDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  DisableAllOutput(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(OscControllerDisableAllOutputDesc, GenericVoidValue.fromPartial(request), metadata);
  }
}

export const OscControllerDesc = { serviceName: "sushi_rpc.OscController" };

export const OscControllerGetSendIPDesc: UnaryMethodDefinitionish = {
  methodName: "GetSendIP",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericStringValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const OscControllerGetSendPortDesc: UnaryMethodDefinitionish = {
  methodName: "GetSendPort",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const OscControllerGetReceivePortDesc: UnaryMethodDefinitionish = {
  methodName: "GetReceivePort",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericIntValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const OscControllerGetEnabledParameterOutputsDesc: UnaryMethodDefinitionish = {
  methodName: "GetEnabledParameterOutputs",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = OscParameterOutputList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const OscControllerEnableOutputForParameterDesc: UnaryMethodDefinitionish = {
  methodName: "EnableOutputForParameter",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const OscControllerDisableOutputForParameterDesc: UnaryMethodDefinitionish = {
  methodName: "DisableOutputForParameter",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ParameterIdentifier.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const OscControllerEnableAllOutputDesc: UnaryMethodDefinitionish = {
  methodName: "EnableAllOutput",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const OscControllerDisableAllOutputDesc: UnaryMethodDefinitionish = {
  methodName: "DisableAllOutput",
  service: OscControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface SessionController {
  SaveSession(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<SessionState>;
  RestoreSession(request: DeepPartial<SessionState>, metadata?: grpc.Metadata): Promise<GenericVoidValue>;
}

export class SessionControllerClientImpl implements SessionController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.SaveSession = this.SaveSession.bind(this);
    this.RestoreSession = this.RestoreSession.bind(this);
  }

  SaveSession(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Promise<SessionState> {
    return this.rpc.unary(SessionControllerSaveSessionDesc, GenericVoidValue.fromPartial(request), metadata);
  }

  RestoreSession(request: DeepPartial<SessionState>, metadata?: grpc.Metadata): Promise<GenericVoidValue> {
    return this.rpc.unary(SessionControllerRestoreSessionDesc, SessionState.fromPartial(request), metadata);
  }
}

export const SessionControllerDesc = { serviceName: "sushi_rpc.SessionController" };

export const SessionControllerSaveSessionDesc: UnaryMethodDefinitionish = {
  methodName: "SaveSession",
  service: SessionControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SessionState.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SessionControllerRestoreSessionDesc: UnaryMethodDefinitionish = {
  methodName: "RestoreSession",
  service: SessionControllerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SessionState.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GenericVoidValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface NotificationController {
  SubscribeToTransportChanges(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Observable<TransportUpdate>;
  SubscribeToEngineCpuTimingUpdates(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Observable<CpuTimings>;
  SubscribeToTrackChanges(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Observable<TrackUpdate>;
  SubscribeToProcessorChanges(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Observable<ProcessorUpdate>;
  SubscribeToParameterUpdates(
    request: DeepPartial<ParameterNotificationBlocklist>,
    metadata?: grpc.Metadata,
  ): Observable<ParameterUpdate>;
  SubscribeToPropertyUpdates(
    request: DeepPartial<PropertyNotificationBlocklist>,
    metadata?: grpc.Metadata,
  ): Observable<PropertyValue>;
}

export class NotificationControllerClientImpl implements NotificationController {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.SubscribeToTransportChanges = this.SubscribeToTransportChanges.bind(this);
    this.SubscribeToEngineCpuTimingUpdates = this.SubscribeToEngineCpuTimingUpdates.bind(this);
    this.SubscribeToTrackChanges = this.SubscribeToTrackChanges.bind(this);
    this.SubscribeToProcessorChanges = this.SubscribeToProcessorChanges.bind(this);
    this.SubscribeToParameterUpdates = this.SubscribeToParameterUpdates.bind(this);
    this.SubscribeToPropertyUpdates = this.SubscribeToPropertyUpdates.bind(this);
  }

  SubscribeToTransportChanges(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Observable<TransportUpdate> {
    return this.rpc.invoke(
      NotificationControllerSubscribeToTransportChangesDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  SubscribeToEngineCpuTimingUpdates(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Observable<CpuTimings> {
    return this.rpc.invoke(
      NotificationControllerSubscribeToEngineCpuTimingUpdatesDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  SubscribeToTrackChanges(request: DeepPartial<GenericVoidValue>, metadata?: grpc.Metadata): Observable<TrackUpdate> {
    return this.rpc.invoke(
      NotificationControllerSubscribeToTrackChangesDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  SubscribeToProcessorChanges(
    request: DeepPartial<GenericVoidValue>,
    metadata?: grpc.Metadata,
  ): Observable<ProcessorUpdate> {
    return this.rpc.invoke(
      NotificationControllerSubscribeToProcessorChangesDesc,
      GenericVoidValue.fromPartial(request),
      metadata,
    );
  }

  SubscribeToParameterUpdates(
    request: DeepPartial<ParameterNotificationBlocklist>,
    metadata?: grpc.Metadata,
  ): Observable<ParameterUpdate> {
    return this.rpc.invoke(
      NotificationControllerSubscribeToParameterUpdatesDesc,
      ParameterNotificationBlocklist.fromPartial(request),
      metadata,
    );
  }

  SubscribeToPropertyUpdates(
    request: DeepPartial<PropertyNotificationBlocklist>,
    metadata?: grpc.Metadata,
  ): Observable<PropertyValue> {
    return this.rpc.invoke(
      NotificationControllerSubscribeToPropertyUpdatesDesc,
      PropertyNotificationBlocklist.fromPartial(request),
      metadata,
    );
  }
}

export const NotificationControllerDesc = { serviceName: "sushi_rpc.NotificationController" };

export const NotificationControllerSubscribeToTransportChangesDesc: UnaryMethodDefinitionish = {
  methodName: "SubscribeToTransportChanges",
  service: NotificationControllerDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TransportUpdate.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const NotificationControllerSubscribeToEngineCpuTimingUpdatesDesc: UnaryMethodDefinitionish = {
  methodName: "SubscribeToEngineCpuTimingUpdates",
  service: NotificationControllerDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CpuTimings.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const NotificationControllerSubscribeToTrackChangesDesc: UnaryMethodDefinitionish = {
  methodName: "SubscribeToTrackChanges",
  service: NotificationControllerDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = TrackUpdate.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const NotificationControllerSubscribeToProcessorChangesDesc: UnaryMethodDefinitionish = {
  methodName: "SubscribeToProcessorChanges",
  service: NotificationControllerDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return GenericVoidValue.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ProcessorUpdate.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const NotificationControllerSubscribeToParameterUpdatesDesc: UnaryMethodDefinitionish = {
  methodName: "SubscribeToParameterUpdates",
  service: NotificationControllerDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return ParameterNotificationBlocklist.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ParameterUpdate.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const NotificationControllerSubscribeToPropertyUpdatesDesc: UnaryMethodDefinitionish = {
  methodName: "SubscribeToPropertyUpdates",
  service: NotificationControllerDesc,
  requestStream: false,
  responseStream: true,
  requestType: {
    serializeBinary() {
      return PropertyNotificationBlocklist.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = PropertyValue.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;
    streamingTransport?: grpc.TransportFactory;
    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;
      streamingTransport?: grpc.TransportFactory;
      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }

  invoke<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Observable<any> {
    const upStreamCodes = this.options.upStreamRetryCodes ?? [];
    const DEFAULT_TIMEOUT_TIME: number = 3_000;
    const request = { ..._request, ...methodDesc.requestType };
    const transport = this.options.streamingTransport ?? this.options.transport;
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Observable((observer) => {
      const upStream = () => {
        const client = grpc.invoke(methodDesc, {
          host: this.host,
          request,
          ...(transport !== undefined ? { transport } : {}),
          metadata: maybeCombinedMetadata ?? {},
          debug: this.options.debug ?? false,
          onMessage: (next) => observer.next(next),
          onEnd: (code: grpc.Code, message: string, trailers: grpc.Metadata) => {
            if (code === 0) {
              observer.complete();
            } else if (upStreamCodes.includes(code)) {
              setTimeout(upStream, DEFAULT_TIMEOUT_TIME);
            } else {
              const err = new Error(message) as any;
              err.code = code;
              err.metadata = trailers;
              observer.error(err);
            }
          },
        });
        observer.add(() => client.close());
      };
      upStream();
    }).pipe(share());
  }
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
